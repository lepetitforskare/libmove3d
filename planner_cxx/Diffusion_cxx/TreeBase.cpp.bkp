/*
 * BasicTree.cpp
 *
 *  Created on: Jul 24, 2009
 *      Author: jmainpri
 */

#include "TreeBase.hpp"

#include "Util-pkg.h"
#include "P3d-pkg.h"
#include "Planner-pkg.h"
#include "Graphic-pkg.h"
#include "Move3d-pkg.h"
#include "Collision-pkg.h"
#include "Localpath-pkg.h"
#include "P3d-pkg.h"
#include "Bio-pkg.h"

#include <vector>
#include <map>
#include <iostream>
#include <sstream>
#include <fstream>
#include <tr1/memory>
#include <algorithm>

#include "../../userappli/StatCostStructure.hpp"
#include "c_to_qt.h"

using namespace std;

int nb_connect_node_to_Comp=0;

TreeBase::TreeBase(p3d_graph* G, int (*stop_func)(), void (*draw_func)()) :
	mConsecutiveFailures(0), _stop_func(stop_func), _draw_func(draw_func),
	mR(new Robot(G->rob)), mG(new Graph(G ? G : p3d_create_graph(),
			mR,
			new LocalpathFactory(),
			new SamplingAPI(mR))), mStart(NULL), mGoal(NULL) {

	shared_ptr<Configuration> startConf = mR->getRobotPos().copy();
	shared_ptr<Configuration> goalConf;

	// Check if goal is in collision
	if (ENV.getBool(Env::expandToGoal)) {
		goalConf = mR->getGoto().copy();
		if (mR->isInCollision(*goalConf)) {
			// TODO: exception
			cout
			<< "Diffusion process stopped: \
			Goal configuration in collision << "
			<< endl;
		}
	}

	// If startConf and/or goalConf are not in the graph, add them
	Node* nS(mG->searchConf(startConf));
	mStart = nS ? nS : mG->insertExtremalNode(startConf);

	cout << "---------- Start Configuration -----------" << endl;
	if(!nS){
		cout << "Attention nStart was not in Graph" << endl;
	}
	mStart->print();

	if (ENV.getBool(Env::biDir) || ENV.getBool(Env::expandToGoal)) {
		Node* nG(mG->searchConf(goalConf));
		mGoal = nG ? nG : mG->insertExtremalNode(goalConf);
		cout << "----------- Goal Configuration -----------" << endl;
		if(!nG){
			cout << "Attention nGoal was not in Graph" << endl;
		}
		mGoal->print();
	}

	Expansion = new TreeExpansionMethod(mG);
}

void TreeBase::reset(){
	delete(mG);
	delete(Expansion);
//	TreeBase* ptrDiffision = new TreeBase(NULL,_stop_func,_draw_func);
//	this = ptrDiffision;
}

TreeBase::~TreeBase() {
	delete(mG);
	delete(Expansion);
}

shared_ptr<Configuration> TreeBase::diffuseOneConf(shared_ptr<Configuration> qCurrent) {
	Localpath path(qCurrent,mR->shoot());
	return (path.confAtParam(std::min(path.length(), Expansion->step())));
}

void TreeBase::checkStopByWeight(Node* n) {
	double stopWeight;
	int signStopWeight;
	p3d_GetStopWeightAndSign(&stopWeight, &signStopWeight);
	if (signStopWeight * (n->mN->weight - stopWeight) > 0) {
		p3d_SetStopValue(true);
		p3d_SetDiffuStoppedByWeight(true);
	}
}

void TreeBase::connectNodeToComp(Node* node, Node* compNode) {

	if (p3d_GetIsCostFuncSpace()){
		costConnectNodeToComp(node, compNode);
	}
	else{
		mG->connectNodeToComp(node, compNode);
	}

}

Node* TreeBase::connectNode(Node* currentNode, Localpath& path, double pathDelta,
		Node* directionNode, double currentCost, int& nbCreatedNodes) {
	if ((pathDelta == 1. && directionNode)) {
		p3d_MergeComp(
				mG->getGraph(),
				currentNode->mN,
				directionNode->mN,
				path.length());

		return (directionNode);
	} else {
		Node* newNode = insertNode(
				path.mEnd,
				currentNode,
				path.length(),
				currentCost);

		nbCreatedNodes++;
		return (newNode);
	}
}

Node* TreeBase::insertNode(shared_ptr<Configuration> q, Node* expansionNode,
		double expansionDist, double currentCost) {

	Node* node(mG->insertRrtLinkingNode(q, expansionNode, expansionDist));

	p3d_graph* g(mG->getGraph());

	// Cost updates
	if (p3d_GetIsCostFuncSpace()) {
		p3d_SetNodeCost(g, node->mN, currentCost);
		//for adaptive variant, new temp is refreshed except if it is going down.
		if (currentCost < expansionNode->mN->cost)
			node->mN->temp = expansionNode->mN->temp;
		else
			node->mN->temp = expansionNode->mN->temp/2.;
	}

	//weight updates
	if (p3d_GetIsWeightedChoice())
		p3d_SetNodeWeight(g, node->mN);

	//check stop conditions
	if (p3d_GetIsWeightStopCondition())
		this->checkStopByWeight(node);

	// Graph updates for RANDOM_IN_SHELL method
	if (Expansion->getNodeMethod() == RANDOM_IN_SHELL_METH) {
		p3d_SetNGood(p3d_GetNGood()+1);
		if (node->mN->weight > g->CurPbLevel) {
			g->CurPbLevel = node->mN->weight;
			g->n_consec_pb_level = 0;
			g->n_consec_fail_pb_level = 0;
			if (p3d_GetNGood() > 2)
				g->critic_cur_pb_level = g->CurPbLevel;
		} else {
			g->n_consec_pb_level++;
			g->n_consec_fail_pb_level = 0;
		}
	}

	//Additional cycles through edges addition if the flag is active
	if (ENV.getBool(Env::addCycles))
		addCycles(*node);
	return (node);
}

void TreeBase::addCycles(Node& newNode) {
	double longStep = 3.*Expansion->step();

	// List of closest Nodes
	p3d_list_node* listDistNodePt = p3d_listNodeInDist(
			mR->getP3dRob(),
			newNode.mN->comp,
			newNode.mN,
			longStep);

	p3d_list_node* savedListDistNodePt = listDistNodePt;

	// Loop on the list
	while (listDistNodePt) {

		// Keep only closest
		if (!p3d_IsSmallDistInGraph(
				mG->getGraph(),
				newNode.mN,
				listDistNodePt->N,
				5,
				Expansion->step())) {

			Node& 	closeNode = *mG->getNode(listDistNodePt->N);
			std::tr1::shared_ptr<Configuration>   closeConf =  mG->getNode(listDistNodePt->N)->getConfSP();

			Localpath path = Localpath(newNode.getConfSP(),closeConf);

			if (path.valid()
					&& costTestSucceeded(&newNode,*closeConf, closeConf->cost())
					&& costTestSucceeded(&closeNode, *(newNode.getConf()),closeConf->cost())) {
				// cout << "create a cycle edge" << endl;
				p3d_create_edges(mG->getGraph(), newNode.mN, listDistNodePt->N,path.length());
				newNode.mN->edges->E->for_cycle = true;
			}
		}
		listDistNodePt = listDistNodePt->next;
	}

	while (savedListDistNodePt) {
		p3d_list_node* destroyListNodePt = savedListDistNodePt;
		savedListDistNodePt = savedListDistNodePt->next;
		MY_FREE(destroyListNodePt, p3d_list_node, 1);
	}
}

bool TreeBase::trajFound()
{
	return(mGoal ?
			mG->inSameComponent(mStart, mGoal) :
				false);
}

void TreeBase::writeTrajectoryPdbs(std::string filename, double granularity,
		Dist* dist) {
	p3d_rob* robotPt(mG->getRobot()->getP3dRob());
	uint filenumber(0);
	int njnt(robotPt->njoints);

	double dmax(p3d_get_env_dmax());
	//  double dmax = p3d_get_env_graphic_dmax();

	if (robotPt->tcur == NULL) {
		std::cout << "TreeBase::writeTrajectoryPdbs: no current trajectory"
		<< std::endl;
		return;
	}

	shared_ptr<std::fstream>
	trajFile(open_file("traj.txt", std::ios_base::out));
	p3d_localpath* localpathPt(robotPt->tcur->courbePt);
	double* distances= MY_ALLOC(double, njnt+1);
	double currentDist(0);
	double nextDist(0);

	std::tr1::shared_ptr<Localpath> path;
	double param(0.);
	std::tr1::shared_ptr<Configuration> lastConfig;

	while (true) {
		bool changed(false);
		if (path.get() && (param > path->length()-EPS6 && localpathPt->next_lp)) {
			localpathPt = localpathPt->next_lp;
			param = 0;
			changed = true;
		}
		if (!path.get() || changed) {
			configPt
			q1(localpathPt->config_at_param(robotPt, localpathPt, 0.0));
			configPt q2(localpathPt->config_at_param(robotPt, localpathPt,
					localpathPt->range_param));
			path = std::tr1::shared_ptr<Localpath>(new Localpath(mG->getRobot()->copyConfig(q1), mG->getRobot()->copyConfig(q2)));
			free(q1);
			free(q2);
		}

		std::tr1::shared_ptr<Configuration> q(path->confAtParam(param));

		if(lastConfig.get())
			currentDist += dist->compute(*mG->getRobot(), *lastConfig, *q);

		// approximation : deplacement is always greater than wanted
		if(currentDist >= nextDist || (!localpathPt->next_lp && param >= path->length()-EPS6))
		{
			std::stringstream ss;
			ss << filenumber;
			mG->getRobot()->setAndUpdate(*q);
			std::string wholename("./test/" + filename + ss.str() + ".pdb");
			move3d_to_pdb(robotPt, wholename.c_str(), filenumber, trajExpMinNONE);
#ifdef STOCHASTIC
			(*trajFile) << currentDist << " " << compute_energy() << " " << filenumber << std::endl;
#endif
			filenumber++;
			if(!localpathPt->next_lp && param >= path->length() - EPS6)
				break;
			nextDist += granularity;
		}

		for (int i(0); i <= njnt; i++)
		{
			distances[i] = dmax;
		}

		param += localpathPt->stay_within_dist(robotPt, localpathPt,
				param, FORWARD, distances);

		lastConfig = q;
	}

	MY_FREE(distances, double, njnt+1);
}

/**
 * ExpandProcess
 *  General function expanding a node toward a direction
 * of expansion. The mode of expansion depends of the
 * expansion choice selected.
 */
int TreeBase::expandProcess(Node& expansionNode,
		shared_ptr<Configuration> directionConfig,
		Node* directionNode,
		Env::expansionMethod method) {

	if(method == Env::costConnect){
		return ExpandCostConnect(expansionNode,
				directionConfig,
				directionNode,
				method,
				false);
	}

	bool extensionSucceeded(false);
	bool failed(false);
	int nbCreatedNodes(0);
	Node* fromNode(&expansionNode);
	Node* extensionNode(NULL);
	shared_ptr<Localpath> directionLocalpath;
	double positionAlongDirection(0.);
	shared_ptr<Localpath> extensionLocalpath;
	double extensionCost(0.);
	bool firstIteration(true);

	// Perform extension toward directionConfig
	// Additional nodes creation in the nExtend case, but without checking for expansion control
	while(firstIteration ||
			(method == Env::nExtend && !failed && positionAlongDirection < 1.))
	{


		directionLocalpath = shared_ptr<Localpath>(new Localpath(
				fromNode->getConfSP(),
				directionConfig));

		extensionSucceeded = Expansion->nextStep(*directionLocalpath,
				directionNode, positionAlongDirection, extensionLocalpath, method);

		failed |= !extensionSucceeded;

		if(failed){
			int nbCollFail = ENV.getInt(Env::nbCollExpanFailed);
			nbCollFail++;
			ENV.setInt(Env::nbCollExpanFailed,nbCollFail);

			if(ENV.getBool(Env::printCollFail)){
				cout << "nbCollFail = " << nbCollFail << endl;
			}
		}

		// Transition test for cost spaces, increase temperature in case of failure
		if(!failed && p3d_GetIsCostFuncSpace())
		{
			extensionCost = extensionLocalpath->mEnd->cost();
			if(!costTestSucceeded(fromNode, *extensionLocalpath->mEnd, extensionCost))
			{
				adjustTemperature(false, fromNode);
				failed = true;
				int nbCostFail = ENV.getInt(Env::nbCostTransFailed);
				nbCostFail++;
				ENV.setInt(Env::nbCostTransFailed,nbCostFail);
				if(ENV.getBool(Env::printCostFail))
					cout << "nbCostFail = " << nbCostFail << endl;
			}
		}
		// Expansion Control
		if(firstIteration && !failed)
		{
			if(ENV.getBool(Env::expandControl) &&
					!Expansion->expandControl(*directionLocalpath, positionAlongDirection, expansionNode))
				failed = true;
		}

		// Add node to graph if everything succeeded
		if(!failed)
		{
			extensionNode = connectNode(fromNode, *extensionLocalpath, positionAlongDirection, directionNode, extensionCost, nbCreatedNodes);
			// In cost space, decrease temperature if the accepted cost is higher
			if(p3d_GetIsCostFuncSpace() && extensionCost > fromNode->getCost()){
				adjustTemperature(true, extensionNode);
			}

			// costTemp
			//fprintf(traj_file, "%d, %5.6f, %5.20f\n", extensionNode->mN->num, extensionCost , extensionNode->getComp()->temperature);

		}

		if(firstIteration && failed){
			Expansion->expansionFailed(expansionNode);
		}

		fromNode = extensionNode;
		firstIteration = false;
	}

	if(p3d_GetIsCostFuncSpace() && (p3d_GetCostMethodChoice() == MAXIMAL_THRESHOLD)) {
		p3d_updateCostThreshold();
	}

	return nbCreatedNodes;
}

