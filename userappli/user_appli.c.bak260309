#include "UserAppli-pkg.h"
#include "Planner-pkg.h"
#include "P3d-pkg.h"
#include "Graphic-pkg.h"
#include "Move3d-pkg.h"
#include "Util-pkg.h"
#include "Localpath-pkg.h"
#include "Collision-pkg.h"
#include <time.h>

static void p3d_reload_conf(void);
static void p3d_generate_pos_set(void);
static void p3d_reset_graph(p3d_graph * graph);
static void p3d_destroy_pos_set(void);
static void p3d_globalPDRSequence(void);
static void p3d_generate_multiPos_set(void);

static configPt qinit = NULL;
static configPt qgoal = NULL;
static configPt configSet [50][2];
enum {ALLPRM, BRIDGEOB, PDR_KPRM, IKSOL, GLOBAL, SPECIFIC, KUKAGLOB, KUKASPE, SPESUPERGRAPH};
extern double resultArray[9];
static double resultStorage[200][9];
static char graphName[25][100];
static int testType = GLOBAL;
static int NB_SHOOTS = 30000;

void p3d_random_qinit_qgoal(int automatic) {
  pp3d_rob r = (pp3d_rob)p3d_get_desc_curid(P3D_ROBOT);
  int col = 0, nbNodes = 0, selectedNode = 0;
  p3d_node ** nodes = NULL;

  if(r->GRAPH == NULL){
    p3d_create_graph();
  }
  //initialisation de la configuration de dÃ©part
//   do {
//     p3d_standard_shoot(r, qinit,0);
//     p3d_set_and_update_this_robot_conf_without_cntrt(r,qinit);
//   } while(p3d_col_test());
  nodes = p3d_APInode_shoot_multisol(r->GRAPH, &nbNodes);
  selectedNode = (int)p3d_random(0, nbNodes);
  qinit = p3d_copy_config(r, (nodes[selectedNode])->q);
  p3d_copy_iksol(r->cntrt_manager, (nodes[selectedNode])->iksol, &(r->ikSolPos));
//   r->ROBOT_POS = p3d_copy_config(r,qinit);
  for(int i = 0; i < nbNodes; i++){
    p3d_APInode_desalloc(r->GRAPH, nodes[i]);
  }
  //initialisation de la configuration d'arrivÃ©e
  nbNodes = 0;
  do {
    for(int i = 0; i < nbNodes; i++){
      p3d_APInode_desalloc(r->GRAPH, nodes[i]);
    }
    nodes = p3d_APInode_shoot_multisol(r->GRAPH, &nbNodes);
    selectedNode = (int)p3d_random(0, nbNodes);
    qgoal = p3d_copy_config(r, (nodes[selectedNode])->q);

    p3d_localpath* localpathPt = p3d_local_planner(r,qinit,qgoal);
    int ntest = 0;
    col = p3d_unvalid_localpath_test(r, localpathPt, &ntest);
  } while(!col);
  p3d_copy_iksol(r->cntrt_manager, (nodes[selectedNode])->iksol, &(r->ikSolGoto));
//   r->ROBOT_GOTO = p3d_copy_config(r,qgoal);
  for(int i = 0; i < nbNodes; i++){
    p3d_APInode_desalloc(r->GRAPH, nodes[i]);
  }
  //printf("localpath = %d", (p3d_local_planner(r,qinit,qgoal))->valid);
  if (!automatic){
    p3d_set_and_update_robot_conf(qinit);
    g3d_refresh_allwin_active();
    printf("ikSol Cur\n");
    p3d_print_iksol(r->cntrt_manager, r->ikSolPos);
    sleep(1);
    p3d_set_and_update_robot_conf(qgoal);
    printf("ikSol Goto\n");
    p3d_print_iksol(r->cntrt_manager, r->ikSolGoto);
    g3d_refresh_allwin_active();
  }
}

static void p3d_reload_conf(void) {
  pp3d_rob r = (pp3d_rob)p3d_get_desc_curid(P3D_ROBOT);

  p3d_copy_config_into(r,qinit,&(r->ROBOT_POS));
  p3d_set_and_update_robot_conf(qinit);
  g3d_refresh_allwin_active();
  p3d_copy_config_into(r,qgoal,&(r->ROBOT_GOTO));
  p3d_set_and_update_robot_conf(qgoal);
  g3d_refresh_allwin_active();
}

void init_qinit_qgoal(void) {
  pp3d_rob r = (pp3d_rob)p3d_get_desc_curid(P3D_ROBOT);

  qinit = p3d_alloc_config(r);
  qgoal = p3d_alloc_config(r);

  p3d_copy_config_into(r,r->ROBOT_POS,&qinit);
  p3d_copy_config_into(r,r->ROBOT_GOTO,&qgoal);
}

void p3d_computeCoverage(void){
  printf("===========================================\n");
  printf("GLOBAL\n");
  printf("===========================================\n");
  p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
  p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
  double success = 0;
  for(int i = 0; i < 10; i++) {
    p3d_reset_graph(XYZ_GRAPH);
    XYZ_GRAPH = NULL;
    p3d_resetMultiGraph(XYZ_ROBOT);
    printf("##########  TEST N %d  ############\n", i+1);
//         CB_global_search_obj(NULL,0);
    p3d_globalSuperGraphLearn();
//         p3d_globalPDRSequence();
  success += p3d_test_good_graph(XYZ_GRAPH, 1000);
  }
  printf("Taux de reussite Moyen : %f\n", (100*success)/30);
}


void p3d_computeCollisionTime(void){
  p3d_rob * r = (p3d_rob *)p3d_get_desc_curid(P3D_ROBOT);
  configPt q = p3d_alloc_config(r);
  configPt q2 = p3d_alloc_config(r);
  double tu = 0.0, ts = 0.0, nTu = 0.0;
  p3d_localpath * localpathPt = NULL;
  int ntest;

//Shoot
  ChronoOn();
  ChronoTimes(&tu, &ts);
  printf("Time before shoot = %f\n", tu);
  for(int i = 0; i < NB_SHOOTS; i++){
    p3d_standard_shoot(r, q,1);
    p3d_set_and_update_this_robot_conf_with_partial_reshoot(r, q);
    p3d_get_robot_config_into(r, &q);
  }
  ChronoTimes(&tu, &ts);
  printf("Time after shoot = %f\n", tu);
  ChronoOff();

//Collision Shoot
  ChronoOn();
  ChronoTimes(&nTu, &ts);
  printf("Time before col = %f\n", nTu);
  for(int i = 0; i < NB_SHOOTS; i++){
    p3d_standard_shoot(r, q,1);
    p3d_set_and_update_this_robot_conf_with_partial_reshoot(r, q);
    p3d_get_robot_config_into(r, &q);
    p3d_col_test();
  }
  ChronoTimes(&nTu, &ts);
  printf("Time after col = %f\n", nTu);
  ChronoOff();
  printf("Collision time = %f over 1000 = %f\n", (nTu - tu)/NB_SHOOTS, (nTu - tu)*1000/NB_SHOOTS);

  tu = nTu - tu;
//localPath Creation
  ChronoOn();
  for(int i = 0; i < NB_SHOOTS; i++){
    p3d_standard_shoot(r, q,1);
    p3d_set_and_update_this_robot_conf_with_partial_reshoot(r, q);
    p3d_get_robot_config_into(r, &q);
    p3d_col_test();
    p3d_standard_shoot(r, q2,1);
    p3d_set_and_update_this_robot_conf_with_partial_reshoot(r, q2);
    p3d_get_robot_config_into(r, &q2);
    p3d_col_test();
    localpathPt = p3d_local_planner_multisol(r, q, q2, NULL);
  }
  ChronoTimes(&nTu, &ts);
  printf("Time after lp Create = %f\n", nTu - 2*tu);
  ChronoOff();
  tu = nTu - 2*tu;

//localpath Col
  ChronoOn();
  for(int i = 0; i < NB_SHOOTS; i++){
    p3d_standard_shoot(r, q,1);
    p3d_set_and_update_this_robot_conf_with_partial_reshoot(r, q);
    p3d_get_robot_config_into(r, &q);
    p3d_col_test();
    p3d_standard_shoot(r, q2,1);
    p3d_set_and_update_this_robot_conf_with_partial_reshoot(r, q2);
    p3d_get_robot_config_into(r, &q2);
    p3d_col_test();
    localpathPt = p3d_local_planner_multisol(r, q, q2, NULL);
    p3d_unvalid_localpath_test(r, localpathPt, &ntest);
  }
  ChronoTimes(&nTu, &ts);
  printf("Time after lp Create = %f\n", nTu - tu);
  ChronoOff();
  printf("Collision time = %f over 1000 = %f\n", (nTu - tu)/NB_SHOOTS, (nTu - tu)*1000/NB_SHOOTS);
}

void p3d_compute_tests(void) {
  int i,j, nbnode, k = 0, l = 0, tmp = 0, *ikSol = NULL;
  double avNodes = 0.0, avTime = 0.0;
  double targetAverage = 0.0;
  pp3d_rob r = (pp3d_rob)p3d_get_desc_curid(P3D_ROBOT);
  
  switch (testType) {
    case GLOBAL: {
      printf("===========================================\n");
      printf("GLOBAL\n");
      printf("===========================================\n");
      p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
      p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
//       p3d_generate_multiPos_set();
      int fail = 0;
//       double success = 0;
      for(i = 0; i < 5; i++) {
        p3d_reset_graph(XYZ_GRAPH);
        XYZ_GRAPH = NULL;
        //if(p3d_get_multiGraph()){
        p3d_resetMultiGraph(XYZ_ROBOT);
        //}
        printf("##########  TEST N %d  ############\n", i+1);
        CB_global_search_obj(NULL,0);
//         p3d_globalSuperGraphLearn();
//         p3d_globalPDRSequence();
        setTotalCountVar(XYZ_GRAPH);
        mergeStat(XYZ_GRAPH->stat, XYZ_ENV->stat);
        printStatsGraph(XYZ_GRAPH->stat);
//         success += p3d_test_good_graph(XYZ_GRAPH, 1000);
//         for(j = 0; j < 25; j++) {
//           printf("TEST %d\n", j);
//           r->ROBOT_POS = p3d_copy_config(r,configSet[j][0]);
//           r->ROBOT_GOTO = p3d_copy_config(r,configSet[j][1]);
// //           p3d_specificSuperGraphLearn();
//           for(int k = 0; k < 2; k++){//nombre de sous graphs
//             p3d_addStartAndGoalNodeToGraph(configSet[j][0], configSet[j][1], NULL, NULL, r->mg->graphs[k], r);
//             p3d_fillFlatMultiGraph(r, NULL, NULL, k, 2);
//           }
//           p3d_reset_graph(r->GRAPH);
//           r->GRAPH = p3d_create_graph();
//           XYZ_GRAPH = r->GRAPH;
//           p3d_convertFsgToGraph(r->GRAPH, r->mg->fsg);
//           printf("glob %d\n", j);
//           p3d_addStartAndGoalNodeToGraph(configSet[j][0], configSet[j][1], NULL, NULL, r->GRAPH, r);
//           //check if there is solution in this graph or not.
//           if (!p3d_graph_to_traj(r)) {
//             fail++;
//           }else{
//             printf("ok\n");
//           }
//         }
      }
      printStatsEnv(XYZ_ENV->stat);
//       printf("nbFail = %d Average = %f\n", fail, ((double)fail/10));
//       printf("Taux de reussite Moyen : %f\n", (100*success)/20);
      break;
    }
    case SPECIFIC: {
      printf("===========================================\n");
      printf("SPECIFIC\n");
      printf("===========================================\n");
      p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
      p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
      double tu = 0.0, ts = 0.0, time = 0.0;
      for(i = 0; i < 0; i++) {
        CB_del_param_obj(NULL, 0);
        XYZ_GRAPH = NULL;
        printf("##########  TEST N %d  ############\n", i+1);
        ChronoOn();
        CB_specific_search_obj(NULL, 0);
        ChronoTimes(&tu, &ts);
        ChronoOff();
        time += tu;
//         setTotalCountVar(XYZ_GRAPH);
//         getPathStat(XYZ_GRAPH->stat,XYZ_GRAPH->rob->tcur,1);
//         CB_start_optim_obj(NULL,0);
//         getPathStat(XYZ_GRAPH->stat,XYZ_GRAPH->rob->tcur,0);
//         mergeStat(XYZ_GRAPH->stat, XYZ_ENV->stat);
//         printStatsGraph(XYZ_GRAPH->stat);
      }
      printf("Time = %f, Time average = %f\n", time, time/30);
//       printStatsEnv(XYZ_ENV->stat);
      break;
    }
    case SPESUPERGRAPH:{
      printf("===========================================\n");
      printf("SPECIFIC Super Graph\n");
      printf("===========================================\n");
      p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
      p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
//       p3d_generate_multiPos_set();
//       int fail = 0;
//       p3d_reset_graph(XYZ_GRAPH);
//       p3d_resetMultiGraph(XYZ_ROBOT);
//       for(int j = 0; j < 20; j++){
        for(i = 0; i < 10; i++) {
          p3d_reset_graph(XYZ_GRAPH);
          XYZ_GRAPH = NULL;
          //if(p3d_get_multiGraph()){
          p3d_resetMultiGraph(XYZ_ROBOT);
          printf("##########  TEST N %d  ############\n", i+1);
//           r->ROBOT_POS = p3d_copy_config(r,configSet[i][0]);
//           r->ROBOT_GOTO = p3d_copy_config(r,configSet[i][1]);
          p3d_specificSuperGraphLearn();
//           setTotalCountVar(XYZ_GRAPH);
//           mergeStat(XYZ_GRAPH->stat, XYZ_ENV->stat);
//           printStatsGraph(XYZ_GRAPH->stat);
        }
//         printStatsEnv(XYZ_ENV->stat);
//       }
      break;
    }
    case ALLPRM: {
        p3d_set_MOTION_PLANNER(P3D_ALL_PRM);
        p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
        p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
        printf("Entrez K :");
        scanf("%d", &k);
        p3d_set_max_connect(k);
        nbnode = 500;
        for (i = 1; i <= 25; i++) {
          p3d_reset_graph(XYZ_GRAPH);
          p3d_set_NB_NODES(nbnode);
          CB_global_search_obj(NULL,0);
          if (i%5 == 0) {nbnode *= 2;}
          resultStorage[i-1][0] = p3d_get_NB_NODES();
          resultStorage[i-1][1] = resultArray[0];
          resultStorage[i-1][2] = resultArray[2];
          resultStorage[i-1][3] = resultArray[3];
          sprintf(graphName[i-1],"%s%d%s%d%s%d%s","/home/mgharbi/Documents/kprmetroit/",k,"/",p3d_get_NB_NODES(),"/",i%5+1,".graph");
          p3d_write_graph(XYZ_GRAPH,graphName[i-1]);
        }
        //print results
        printf("-------------------------------------------\n");
        printf("k = %d\n", k);
        for(i = 0; i < 25; i++) {
          /* switch (i){
             case (0): printf("Gvis\n"); break;
             case (10): printf("Gretract\n");break;
           }*/
          printf("%s :%f,%f,%f,%f\n", graphName[i], resultStorage[i][0], resultStorage[i][2], resultStorage[i][3], resultStorage[i][4]);
        }
        printf("-------------------------------------------\n");
        break;
      }
    case BRIDGEOB: {
        for(i = 0; i < 30; i++) {
          p3d_random_qinit_qgoal(TRUE);
          printf("===========================================\n");
          printf("VISIBILITY\n");
          printf("===========================================\n");
          p3d_reset_graph(XYZ_GRAPH);
          p3d_set_MOTION_PLANNER(P3D_ISOLATE_LINKING);
          p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
          p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
          p3d_set_NB_TRY(100000);
          CB_specific_search_obj(NULL,0);
          resultStorage[i*5][0] = resultArray[0];
          resultStorage[i*5][1] = resultArray[2];
          resultStorage[i*5][2] = resultArray[4];
          resultStorage[i*5][3] = resultArray[5];
          printf("===========================================\n");
          printf("BRIDGE\n");
          printf("===========================================\n");
          p3d_reset_graph(XYZ_GRAPH);
          p3d_reload_conf();
          p3d_set_MOTION_PLANNER(P3D_BASIC);
          p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
          p3d_set_SAMPLING_CHOICE(P3D_BRIDGE_SAMPLING);
          CB_specific_search_obj(NULL,0);
          resultStorage[i*5+1][0] = resultArray[0];
          resultStorage[i*5+1][1] = resultArray[2];
          resultStorage[i*5+1][2] = resultArray[4];
          resultStorage[i*5+1][3] = resultArray[5];
          printf("===========================================\n");
          printf("OBPRM\n");
          printf("===========================================\n");
          p3d_reset_graph(XYZ_GRAPH);
          p3d_reload_conf();
          p3d_set_MOTION_PLANNER(P3D_BASIC);
          p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
          p3d_set_SAMPLING_CHOICE(P3D_OBPRM_SAMPLING);
          CB_specific_search_obj(NULL,0);
          resultStorage[i*5+2][0] = resultArray[0];
          resultStorage[i*5+2][1] = resultArray[2];
          resultStorage[i*5+2][2] = resultArray[4];
          resultStorage[i*5+2][3] = resultArray[5];
          printf("===========================================\n");
          printf("VIS+BRIDGE\n");
          printf("===========================================\n");
          p3d_reset_graph(XYZ_GRAPH);
          p3d_reload_conf();
          p3d_set_MOTION_PLANNER(P3D_ISOLATE_LINKING);
          p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
          p3d_set_SAMPLING_CHOICE(P3D_BRIDGE_SAMPLING);
          p3d_set_NB_TRY(100000);
          CB_specific_search_obj(NULL,0);
          resultStorage[i*5+3][0] = resultArray[0];
          resultStorage[i*5+3][1] = resultArray[2];
          resultStorage[i*5+3][2] = resultArray[4];
          resultStorage[i*5+3][3] = resultArray[5];
          printf("===========================================\n");
          printf("VIS+OBPRM\n");
          printf("===========================================\n");
          p3d_reset_graph(XYZ_GRAPH);
          p3d_reload_conf();
          p3d_set_MOTION_PLANNER(P3D_ISOLATE_LINKING);
          p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
          p3d_set_SAMPLING_CHOICE(P3D_OBPRM_SAMPLING);
          p3d_set_NB_TRY(100000);
          CB_specific_search_obj(NULL,0);
          resultStorage[i*5+4][0] = resultArray[0];
          resultStorage[i*5+4][1] = resultArray[2];
          resultStorage[i*5+4][2] = resultArray[4];
          resultStorage[i*5+4][3] = resultArray[5];
        }

        printf("-------------------------------------------\n");
        for(i = 0; i < 150; i++) {
          printf("%f,%f,%f,%f",resultStorage[i][0],resultStorage[i][1],resultStorage[i][2],resultStorage[i][3]);
          if (i%5 == 4) {
            printf("\n");
          } else {
            printf(",");
          }
        }
        printf("-------------------------------------------\n");
        break;
      }
    case PDR_KPRM: {
      //on genere toutes les configurations a tester.
      p3d_generate_pos_set();
      //PDR
      p3d_set_MOTION_PLANNER(P3D_ISOLATE_LINKING);
      p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
      p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
      p3d_set_test_reductib(1);
      p3d_set_is_visibility_discreet(1);
      for(i = 9; i < 10; i++) {//10
        for(j = 0; j < 5; j++){//10 roadmaps par nbtry
          p3d_reset_graph(XYZ_GRAPH);
          targetAverage = 0;
          printf("################################\n");
          printf("############ Visi %d %d #########\n", (i+1)*50, j);
          printf("################################\n");
          p3d_set_cycles(0);
          p3d_set_NB_TRY(10000);
          CB_global_search_obj(NULL,0);
          //tmp = resultArray[2];
          p3d_set_cycles(1);
          p3d_set_NB_TRY((i+1)*160);
          CB_global_search_obj(NULL,0);
          for(k = 0, l = 0; k < 50; k++){
            r->ROBOT_POS = p3d_copy_config(r,configSet[k][0]);
            r->ROBOT_GOTO = p3d_copy_config(r,configSet[k][1]);
            tmp = p3d_compute_traj_lenght(1,0);
            if (tmp != 0){
              targetAverage += tmp;
              l++;
            }
          }
          for (k = 0; k < 7; k++){
            resultStorage[100+i*10+j][k] = resultArray[k];
          }
          resultStorage[100+i*10+j][7] = targetAverage/l;
          resultStorage[100+i*10+j][8] = l;
        }
      }
      for(i = 0; i < 200; i++){
        printf("%f,%f,%f,%f,%f,%f,%f,%f,%f\n",resultStorage[i][0],resultStorage[i][1],resultStorage[i][2],resultStorage[i][6],resultStorage[i][3],resultStorage[i][4],resultStorage[i][5], resultStorage[i][7],resultStorage[i][8]);
        if (i == 99){
          printf("<---------------------------------------------->\n");
        }
      }
      p3d_destroy_pos_set();
      break;
    }
    case IKSOL: {
      qinit = p3d_alloc_config(r);
      qgoal = p3d_alloc_config(r);

      p3d_set_ik_choice(IK_MULTISOL);

//         CB_specific_search_obj(NULL,0); // calcul d'un premier graph
      avTime = resultArray[2];
      avNodes = resultArray[0];
      for (j = 0; j < 1; j++){
        ikSol = MY_ALLOC(int, r->cntrt_manager->ncntrts);
        for(i = 0; i < r->cntrt_manager->ncntrts; i++){//gÃ©nÃ©ration d'un ikSol pour le start
          ikSol[i] = 0;
          while (ikSol[i]%2 != 1){
            ikSol[i] = p3d_get_random_ikSol(r->cntrt_manager, i);
          }
        }
        printf("START POS IKSOL\n");
        p3d_print_iksol(r->cntrt_manager, ikSol);
        do {
          do{
            p3d_shoot(r, qinit,0);
          } while (!p3d_set_and_update_this_robot_conf_multisol(r, qinit, NULL, 0, ikSol));
//             p3d_set_and_update_this_robot_conf_multisol(r, qinit, NULL, 0, ikSol);
        } while(p3d_col_test());
        g3d_refresh_allwin_active();
        p3d_copy_config_into(r,qinit, &(r->ROBOT_POS));
        p3d_copy_iksol(r->cntrt_manager,ikSol, &(r->ikSolPos));


        for(i = 0; i < r->cntrt_manager->ncntrts; i++){//gÃ©nÃ©ration d'un ikSol pour le goto
          ikSol[i] = 0;
          while (ikSol[i]%2 != 1){
            ikSol[i] = p3d_get_random_ikSol(r->cntrt_manager, i);
          }
        }
        printf("GOTO POS IKSOL\n");
        p3d_print_iksol(r->cntrt_manager, ikSol);
        do {
          do{
            p3d_shoot(r, qgoal,0);
          } while (!p3d_set_and_update_this_robot_conf_multisol(r, qgoal, NULL, 0, ikSol));
        } while(p3d_col_test());
        g3d_refresh_allwin_active();
        p3d_copy_config_into(r,qgoal, &(r->ROBOT_GOTO));
        p3d_copy_iksol(r->cntrt_manager,ikSol, &(r->ikSolGoto));

        p3d_set_and_update_robot_conf(r->ROBOT_POS);
        g3d_refresh_allwin_active();
//           sleep(5);
        p3d_set_and_update_robot_conf(r->ROBOT_GOTO);
        g3d_refresh_allwin_active();
//           sleep(5);
//           CB_specific_search_obj(NULL,0);
//           avTime += resultArray[2];
//           avNodes += resultArray[0];
//           printf("temps = %f, nodes = %f\n", resultArray[2],resultArray[0]);
      }
//         printf("######################################\n");
//         printf("Time = %f, Nodes = %f\n", (resultArray[2]-avTime)/j, (resultArray[0]-avNodes)/j);
//         printf("######################################\n");
      p3d_destroy_config(r, qinit);
      p3d_destroy_config(r, qgoal);
    }
    case KUKAGLOB:{
      p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
      p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
      for(i = 0; i < 30; i++) {
        p3d_reset_graph(XYZ_GRAPH);
        XYZ_GRAPH = NULL;
        printf("##########  TEST N %d  ############\n", i+1);
        CB_global_search_obj(NULL,0);
//         p3d_set_cycles(1);
//         p3d_set_NB_TRY(100);
//         CB_global_search_obj(NULL,0);
//         p3d_set_cycles(0);
//         p3d_set_NB_TRY(250);
        p3d_rob *robotPt = (p3d_rob *) p3d_get_desc_curid(P3D_ROBOT);
        configPt q[robotPt->nTransition + 2];
        for(int i = 1, j = 0; i < robotPt->nTransition + 1; i++, j++){
          q[i] = robotPt->transitionConfigs[j];
        }
        q[0] = robotPt->ROBOT_POS;
        q[robotPt->nTransition + 1] = robotPt->ROBOT_GOTO;

        for(int i = 0; i < robotPt->nTransition + 1; i++){
          robotPt->ROBOT_POS = q[i];
          robotPt->ROBOT_GOTO = q[i+1];
          CB_specific_search_obj(NULL, 0);
          setTotalCountVar(XYZ_GRAPH);
          getPathStat(XYZ_GRAPH->stat,XYZ_GRAPH->rob->tcur,1);
          CB_start_optim_obj(NULL,0);
          getPathStat(XYZ_GRAPH->stat,XYZ_GRAPH->rob->tcur,0);
        }
        robotPt->ROBOT_POS = q[0];
        robotPt->ROBOT_GOTO = q[robotPt->nTransition + 1];
        //concatenation des trajectoires
        for(int i = robotPt->nt - robotPt->nTransition; i < robotPt->nt; i++){
          p3d_concat_traj(robotPt->t[robotPt->nt-(robotPt->nTransition+1)], robotPt->t[i]);
        }
        robotPt->tcur = robotPt->t[robotPt->nt-(robotPt->nTransition+1)];
        mergeStat(XYZ_GRAPH->stat, XYZ_ENV->stat);
        printStatsGraph(XYZ_GRAPH->stat);
      }
      printStatsEnv(XYZ_ENV->stat);
      break;
    }
    case KUKASPE:{
      p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
      p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
      p3d_set_NB_TRY(1000);
      for(i = 0; i < 30; i++) {
        p3d_reset_graph(XYZ_GRAPH);
        XYZ_GRAPH = NULL;
        printf("##########  TEST N %d  ############\n", i+1);
          p3d_rob *robotPt = (p3d_rob *) p3d_get_desc_curid(P3D_ROBOT);
          configPt q[robotPt->nTransition + 2];
          for(int i = 1, j = 0; i < robotPt->nTransition + 1; i++, j++){
            q[i] = robotPt->transitionConfigs[j];
          }
          q[0] = robotPt->ROBOT_POS;
          q[robotPt->nTransition + 1] = robotPt->ROBOT_GOTO;

          for(int i = 0; i < robotPt->nTransition + 1; i++){
            robotPt->ROBOT_POS = q[i];
            robotPt->ROBOT_GOTO = q[i+1];
            CB_specific_search_obj(NULL, 0);
            setTotalCountVar(XYZ_GRAPH);
            getPathStat(XYZ_GRAPH->stat,XYZ_GRAPH->rob->tcur,1);
            CB_start_optim_obj(NULL,0);
            getPathStat(XYZ_GRAPH->stat,XYZ_GRAPH->rob->tcur,0);
          }
          robotPt->ROBOT_POS = q[0];
          robotPt->ROBOT_GOTO = q[robotPt->nTransition + 1];
          //concatenation des trajectoires
          for(int i = robotPt->nt - robotPt->nTransition; i < robotPt->nt; i++){
            p3d_concat_traj(robotPt->t[robotPt->nt-(robotPt->nTransition+1)], robotPt->t[i]);
          }
          robotPt->tcur = robotPt->t[robotPt->nt-(robotPt->nTransition+1)];
        mergeStat(XYZ_GRAPH->stat, XYZ_ENV->stat);
        printStatsGraph(XYZ_GRAPH->stat);
      }
      printStatsEnv(XYZ_ENV->stat);
      break;
    }
  }
}

void p3d_computeOptimizedTraj(void){
  p3d_set_RANDOM_CHOICE(P3D_RANDOM_SAMPLING);
  p3d_set_SAMPLING_CHOICE(P3D_UNIFORM_SAMPLING);
  p3d_reset_graph(XYZ_GRAPH);
  XYZ_GRAPH = NULL;
//   CB_global_search_obj(NULL,0);
  p3d_rob *robotPt = (p3d_rob *) p3d_get_desc_curid(P3D_ROBOT);
  configPt q[robotPt->nTransition + 2];
  for(int i = 1, j = 0; i < robotPt->nTransition + 1; i++, j++){
    q[i] = robotPt->transitionConfigs[j];
  }
  q[0] = robotPt->ROBOT_POS;
  q[robotPt->nTransition + 1] = robotPt->ROBOT_GOTO;

  for(int i = 0; i < robotPt->nTransition + 1; i++){
    robotPt->ROBOT_POS = q[i];
    robotPt->ROBOT_GOTO = q[i+1];
    CB_specific_search_obj(NULL, 0);
    CB_start_optim_obj(NULL,0);
  }
  robotPt->ROBOT_POS = q[0];
  robotPt->ROBOT_GOTO = q[robotPt->nTransition + 1];
  //concatenation des trajectoires
  for(int i = robotPt->nt - robotPt->nTransition; i < robotPt->nt; i++){
    p3d_concat_traj(robotPt->t[robotPt->nt-(robotPt->nTransition+1)], robotPt->t[i]);
  }
  robotPt->tcur = robotPt->t[robotPt->nt-(robotPt->nTransition+1)];
}

int p3d_compute_traj_lenght(int automatic, int optim){
  p3d_traj* traj;
  p3d_rob* rob = XYZ_ROBOT;
  p3d_node* start = NULL, *goal = NULL;
  configPt qs, qg;
  p3d_list_node *graph_node;
  configPt  qtest;
  double trajLength = 0;
  int i = 0;
  p3d_localpath *localpath = NULL;

  if (rob->GRAPH == NULL){
    printf("Pas de graph.\n");
    return 0;
  }

  /* Nodes start and goal exist ?*/
  graph_node = rob->GRAPH->nodes;
  while(graph_node) {
    qtest = graph_node->N->q;
    if(p3d_equal_config(rob, rob->ROBOT_POS, qtest))  start = graph_node->N;
    if(p3d_equal_config(rob, rob->ROBOT_GOTO, qtest))  goal = graph_node->N;
    if(start && goal) {
      break;
    }
    graph_node = graph_node->next;
  }

  //connecter les qs et qg au graph si il n'y sont pas.
  if (!start){
    qs = p3d_copy_config(rob, rob->ROBOT_POS);
    start = p3d_APInode_make_multisol(rob->GRAPH, qs, rob->ikSolPos);
    p3d_insert_node(rob->GRAPH,start);
    start->type = ISOLATED;
    if (start->type == ISOLATED && !p3d_link_node_graph(start, rob->GRAPH)){
      printf("Je ne trouve pas de trajectoire: Impossible de relier la configuration initiale\n");
      return 0;
    }
  }
  if (!goal){
    qg = p3d_copy_config(rob, rob->ROBOT_GOTO);
    goal = p3d_APInode_make_multisol(rob->GRAPH, qg, rob->ikSolGoto);
    p3d_insert_node(rob->GRAPH,goal);
    goal->type = ISOLATED;
    if (goal->type == ISOLATED && !p3d_link_node_graph(goal, rob->GRAPH)){
      printf("Je ne trouve pas de trajectoire: Impossible de relier la configuration finale\n");
      return 0;
    }
  }

  //initialiser les start et goal search
  rob->GRAPH->search_start = start;
  rob->GRAPH->search_goal = goal;
  rob->GRAPH->search_done = FALSE;
  //voir si il y'a un chemin entre qs et qg
  traj = p3d_graph_to_traj(rob);
  if (traj != NULL){
    if (optim){
      rob->tcur = traj;
      p3d_set_optimization_time(0.001);
      p3d_set_NB_OPTIM(1000);
      p3d_enable_optim_time_limit();
      compute_rand_optim(NULL, &traj);
    }
    localpath = traj->courbePt;
    for (i = 0; i < traj->nloc; i++){
      trajLength += localpath->length_lp;
      localpath = localpath->next_lp;
    }

    if (!automatic){
      printf("Path lenght = %f\n",trajLength);
    }
    return trajLength;
  }else{
    printf("Je ne trouve pas de trajectoire\n");
    return 0;
  }
}

static void p3d_reset_graph(p3d_graph * graph) {
  p3d_del_graph(graph);
  p3d_reinit_array_exhausted_nodes();
  MY_ALLOC_INFO("Apres destruction du graphe");
}

static void p3d_generate_pos_set(){
  int i;
  p3d_rob* rob = XYZ_ROBOT;
  for (i = 0; i < 50; i++){
    p3d_random_qinit_qgoal(1);
    configSet[i][0] = p3d_copy_config(rob,qinit);
    configSet[i][1] = p3d_copy_config(rob,qgoal);
  }
}

static void p3d_generate_multiPos_set(void){
  p3d_rob* rob = XYZ_ROBOT;
  configPt initConf[5];
  configPt goalConf[5];
  configPt tmp = p3d_alloc_config(rob);
  
  for(int i = 0; i < 5; i++){
    initConf[i] = p3d_alloc_config(rob);
    goalConf[i] = p3d_alloc_config(rob);
  }

  //init 0
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 0.000000;
  tmp[7] = 0.000000;
  tmp[8] = 0.000000;
  tmp[9] = 0.000000;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 30.088488;
  tmp[13] = -84.955750;
  tmp[14] = -11.701082;
  tmp[15] = 70.796455;
  tmp[16] = 36.774834;
  tmp[17] = -0.936577;
  tmp[18] = 0.752215;
  tmp[19] = 30.088488;
  tmp[20] = -84.955750;
  tmp[21] = -11.701082;
  tmp[22] = 70.796455;
  tmp[23] = 36.774834;
  tmp[24] = 0.000000;
  tmp[25] = 0.000000;
  p3d_convert_config_deg_to_rad(rob, tmp, &initConf[0]);
  //init 1
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 0.000000;
  tmp[7] = -44.247784;
  tmp[8] = 68.827438;
  tmp[9] = -24.579655;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 5.014758;
  tmp[13] = -84.955750;
  tmp[14] = -11.701082;
  tmp[15] = 70.796455;
  tmp[16] = 36.774834;
  tmp[17] = -0.936577;
  tmp[18] = 0.752215;
  tmp[19] = 5.014758;
  tmp[20] = -86.135696;
  tmp[21] = -11.701082;
  tmp[22] = 70.796455;
  tmp[23] = 36.774834;
  tmp[24] = 0.000000;
  tmp[25] = 0.000000;
  p3d_convert_config_deg_to_rad(rob, tmp, &initConf[1]);
  //init 2
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 80.000000;
  tmp[7] = -44.247784;
  tmp[8] = 68.827438;
  tmp[9] = -24.579655;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 70.206490;
  tmp[13] = -120.000000;
  tmp[14] = -91.937073;
  tmp[15] = 70.796455;
  tmp[16] = 36.774834;
  tmp[17] = -0.936577;
  tmp[18] = 0.752215;
  tmp[19] = 43.461155;
  tmp[20] = -86.135696;
  tmp[21] = -61.848572;
  tmp[22] = 77.876099;
  tmp[23] = 36.774834;
  tmp[24] = 0.000000;
  tmp[25] = 0.000000;
  p3d_convert_config_deg_to_rad(rob, tmp, &initConf[2]);
  //init3
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = -0.786629;
  tmp[7] = -34.513275;
  tmp[8] = 84.092918;
  tmp[9] = -49.579643;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 63.520149;
  tmp[13] = -64.896751;
  tmp[14] = -43.461155;
  tmp[15] = 109.734505;
  tmp[16] = 36.774834;
  tmp[17] = -0.936577;
  tmp[18] = 0.752215;
  tmp[19] = 20.058992;
  tmp[20] = -93.215340;
  tmp[21] = -61.848572;
  tmp[22] = 93.215347;
  tmp[23] = 36.774834;
  tmp[24] = 0.000000;
  tmp[25] = 0.000000;
  p3d_convert_config_deg_to_rad(rob, tmp, &initConf[3]);
  //init4
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 3.146505;
  tmp[7] = -68.141594;
  tmp[8] = 78.119469;
  tmp[9] = -9.977875;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 8.357910;
  tmp[13] = -51.917404;
  tmp[14] = -18.387417;
  tmp[15] = 41.297935;
  tmp[16] = 36.774834;
  tmp[17] = -0.936577;
  tmp[18] = 0.752215;
  tmp[19] = 20.058992;
  tmp[20] = -55.457226;
  tmp[21] = -45.132744;
  tmp[22] = 38.938049;
  tmp[23] = 140.412979;
  tmp[24] = -15.685842;
  tmp[25] = 17.566372;
  p3d_convert_config_deg_to_rad(rob, tmp, &initConf[4]);
  //goto 0
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 0.000000;
  tmp[7] = 0.000000;
  tmp[8] = 0.000000;
  tmp[9] = 0.000000;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 90.265488;
  tmp[13] = -92.035400;
  tmp[14] = -55.162239;
  tmp[15] = 90.855461;
  tmp[16] = -78.564400;
  tmp[17] = -19.373156;
  tmp[18] = 87.477875;
  tmp[19] = 56.833824;
  tmp[20] = -103.834808;
  tmp[21] = -63.520157;
  tmp[22] = 89.675514;
  tmp[23] = -122.025566;
  tmp[24] = -4.623896;
  tmp[25] = 77.743370;
  p3d_convert_config_deg_to_rad(rob, tmp, &goalConf[0]);
  //goto 1
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = -0.786629;
  tmp[7] = -0.884957;
  tmp[8] = 0.884957;
  tmp[9] = 0.000000;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 80.235985;
  tmp[13] = -64.896751;
  tmp[14] = 95.280243;
  tmp[15] = -41.297935;
  tmp[16] = -88.593903;
  tmp[17] = -4.623896;
  tmp[18] = 23.761063;
  tmp[19] = 88.593895;
  tmp[20] = -63.716816;
  tmp[21] = 96.951828;
  tmp[22] = -38.938049;
  tmp[23] = -85.250732;
  tmp[24] = -0.322027;
  tmp[25] = 18.451328;
  p3d_convert_config_deg_to_rad(rob, tmp, &goalConf[1]);
  //goto 2
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 2.359886;
  tmp[7] = -1.769909;
  tmp[8] = 12.389381;
  tmp[9] = -10.619472;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 81.907578;
  tmp[13] = -56.637169;
  tmp[14] = 88.593895;
  tmp[15] = -113.274338;
  tmp[16] = -88.593903;
  tmp[17] = -39.038841;
  tmp[18] = -38.185841;
  tmp[19] = 101.966568;
  tmp[20] = -92.035400;
  tmp[21] = -63.520157;
  tmp[22] = 29.498520;
  tmp[23] = -86.922325;
  tmp[24] = -5.238446;
  tmp[25] = 3.407081;
  p3d_convert_config_deg_to_rad(rob, tmp, &goalConf[2]);
  //goto3
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 50.344154;
  tmp[7] = -1.769909;
  tmp[8] = 12.389381;
  tmp[9] = -10.619472;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 105.309738;
  tmp[13] = -97.935104;
  tmp[14] = 120.353989;
  tmp[15] = 44.837749;
  tmp[16] = 81.907578;
  tmp[17] = -22.445919;
  tmp[18] = 55.619465;
  tmp[19] = 78.564400;
  tmp[20] = -120.000000;
  tmp[21] = -58.505409;
  tmp[22] = 71.976402;
  tmp[23] = -123.697151;
  tmp[24] = -5.238446;
  tmp[25] = -0.132743;
  p3d_convert_config_deg_to_rad(rob, tmp, &goalConf[3]);
  //goto4
  tmp[0] = 0.000000;
  tmp[1] = 0.000000;
  tmp[2] = 0.000000;
  tmp[3] = 0.000000;
  tmp[4] = 0.000000;
  tmp[5] = 0.000000;
  tmp[6] = 1.573257;
  tmp[7] = -0.884957;
  tmp[8] = 0.884957;
  tmp[9] = 0.000000;
  tmp[10] = 0.000000;
  tmp[11] = 0.000000;
  tmp[12] = 60.176994;
  tmp[13] = -28.318584;
  tmp[14] = -68.534904;
  tmp[15] = 103.834808;
  tmp[16] = 81.907578;
  tmp[17] = -6.467553;
  tmp[18] = -0.132743;
  tmp[19] = 58.505409;
  tmp[20] = -28.318584;
  tmp[21] = -61.848572;
  tmp[22] = 105.014748;
  tmp[23] = 90.265488;
  tmp[24] = -0.936577;
  tmp[25] = -0.132743;
  p3d_convert_config_deg_to_rad(rob, tmp, &goalConf[4]);
  for(int i = 0; i < 5; i++){
    for (int j = 0; j < 5; j++){
      configSet[i*5+j][0] = p3d_copy_config(rob,initConf[i]);
      configSet[i*5+j][1] = p3d_copy_config(rob,goalConf[j]);
    }
  }
  for(int i = 0; i < 5; i++){
    p3d_destroy_config(rob, initConf[i]);
    p3d_destroy_config(rob, goalConf[i]);
  }
}

static void p3d_destroy_pos_set(){
  int i;
  p3d_rob* rob = XYZ_ROBOT;
  int nb_dof = rob->nb_dof;
  
  for (i = 0; i < 50; i++){
    MY_FREE(configSet[i][0],double, (size_t)nb_dof);
    MY_FREE(configSet[i][1],double, (size_t)nb_dof);
  }
}


#ifdef MULTIGRAPH

void p3d_specificSuperGraphLearn(void){
double *arraytimes = MY_ALLOC(double, p3d_get_NB_specific());
  int nfail = 0;
  configPt qs = NULL, qg = NULL;
  double tu = 0.0, ts = 0.0, mgTime = 0.0, gTime = 0.0;
  p3d_rob *robotPt = (p3d_rob *) p3d_get_desc_curid(P3D_ROBOT);
  p3d_graph * graph = NULL, *tmp = NULL;

  p3d_SetDiffuStoppedByWeight(0);
  p3d_SetStopValue(FALSE);

  qs = p3d_copy_config(robotPt, robotPt->ROBOT_POS);
  if (p3d_GetIsExpansionToGoal() == TRUE) {
    qg = p3d_copy_config(robotPt, robotPt->ROBOT_GOTO);
  }

  if (!XYZ_GRAPH){
    graph = p3d_create_graph();
  }else{
    graph = XYZ_GRAPH;
  }

  //compute the specific planner for each part of the system
  for(int j = 0; j < robotPt->mg->nbGraphs; j++){
    p3d_set_user_drawnjnt(robotPt->mg->mgJoints[j]->joints[robotPt->mg->mgJoints[j]->nbJoints - 1]);
    tmp = p3d_setMultiGraphAndActiveDof(robotPt, j);
    p3d_loopSpecificLearn(robotPt, qs, qg, "", 0, arraytimes, &nfail);
    if (p3d_graph_to_traj(robotPt)) {
      g3d_add_traj("Globalsearch", p3d_get_desc_number(P3D_TRAJ));
    }
    gTime += robotPt->mg->graphs[j]->time;
  }
  //create the flat super Graph
  if (graph->nnode == 0){
    robotPt->GRAPH = NULL;
    XYZ_GRAPH = NULL;
    ChronoOn();
    p3d_setAllDofActive(robotPt);
    p3d_flatMultiGraph(robotPt, 1);
    p3d_setAllDofActive(robotPt);
    p3d_convertFsgToGraph(graph, robotPt->mg->fsg);
    ChronoTimes(&tu, &ts);
    ChronoOff();
    mgTime += tu;
    XYZ_GRAPH = graph;
    robotPt->GRAPH = graph;
    p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
    //check if there is solution in this graph or not.
    if (!p3d_graph_to_traj(robotPt)) {
      //continuer la recherche
      printf("Je ne trouve pas en mergeant les traj\n");
      ChronoOn();
      p3d_delFlatSuperGraph(robotPt, robotPt->mg->fsg);
      p3d_flatMultiGraph(robotPt, 0);
      p3d_setAllDofActive(robotPt);
      p3d_del_graph(graph);
      graph = p3d_create_graph();
      p3d_convertFsgToGraph(graph, robotPt->mg->fsg);
      ChronoTimes(&tu, &ts);
      ChronoOff();
      mgTime += tu;
      XYZ_GRAPH = graph;
      robotPt->GRAPH = graph;
      p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
      if (!p3d_graph_to_traj(robotPt)) {
        printf("Je ne trouve pas il faut enrichir\n");
        p3d_doIncrementalConstruction(1);
      }else{
        p3d_print_info_graph(graph);
      }
    }else{//pour les futures requetes
      printf("graph->nnode = %d\n",graph->nnode);
      p3d_delFlatSuperGraph(robotPt, robotPt->mg->fsg);
//       p3d_reset_graph(XYZ_GRAPH);
//       graph = NULL;
//       XYZ_GRAPH = NULL;
    }
  }else{
    XYZ_GRAPH = graph;
    ChronoOn();
    p3d_setAllDofActive(robotPt);
    for(int j = 0; j < robotPt->mg->nbGraphs; j++){
      p3d_fillFlatMultiGraph(robotPt, NULL, NULL, j, 2);
    }
    p3d_setAllDofActive(robotPt);
    p3d_convertFsgToGraph(graph, robotPt->mg->fsg);
    ChronoTimes(&tu, &ts);
    ChronoOff();
    mgTime += tu;
    XYZ_GRAPH = graph;
    robotPt->GRAPH = graph;
    p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
    //check if there is solution in this graph or not.
    if (!p3d_graph_to_traj(robotPt)) {
      printf("Je ne trouve pas il faut enrichir\n");
      p3d_doIncrementalConstruction(1);
    }else{
      p3d_print_info_graph(graph);
    }
  }
  if(p3d_doIncrementalConstruction(-1)){
    p3d_learn(p3d_get_NB_NODES(), fct_stop, fct_draw);
    p3d_setAllDofActive(robotPt);
    graph = XYZ_GRAPH;
    p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
    p3d_doIncrementalConstruction(0);
    printf("graph->nnode = %d\n",graph->nnode);
  }
  printf("gTime = %f\n", gTime);
  printf("mgTime = %f\n", mgTime);
  printf("Total = %f\n", gTime+mgTime);
//   graph->mgTime += mgTime;
//   graph->time += gTime + graph->mgTime;
//   if(STAT){
//     graph->stat->mgTime = graph->mgTime;
//   }
}

// void p3d_specificSuperGraphLearn(void){
//   double *arraytimes = MY_ALLOC(double, p3d_get_NB_specific());
//   int nfail = 0;
//   configPt qs = NULL, qg = NULL;
//   double tu = 0.0, ts = 0.0, mgTime = 0.0, gTime = 0.0;
//   p3d_rob *robotPt = (p3d_rob *) p3d_get_desc_curid(P3D_ROBOT);
// 
//   p3d_SetDiffuStoppedByWeight(0);
//   p3d_SetStopValue(FALSE);
// 
//   if (p3d_get_multiGraph()){
//     qs = p3d_copy_config(robotPt, robotPt->ROBOT_POS);
//     if (p3d_GetIsExpansionToGoal() == TRUE) {
//       qg = p3d_copy_config(robotPt, robotPt->ROBOT_GOTO);
//     }
// 
//     p3d_graph * graph = NULL;
//     //compute the specific planner for each part of the system
//     graph = p3d_create_graph();
//     for(int j = 0; j < robotPt->mg->nbGraphs; j++){
//       p3d_set_user_drawnjnt(robotPt->mg->mgJoints[j]->joints[robotPt->mg->mgJoints[j]->nbJoints - 1]);
//       p3d_setMultiGraphAndActiveDof(robotPt, j);
//       p3d_loopSpecificLearn(robotPt, qs, qg, "", 0, arraytimes, &nfail);
//       if (p3d_graph_to_traj(robotPt)) {
//         g3d_add_traj("Globalsearch", p3d_get_desc_number(P3D_TRAJ));
//       }
//       gTime += robotPt->mg->graphs[j]->time;
//     }
//     //create the flat super Graph
//     robotPt->GRAPH = NULL;
//     XYZ_GRAPH = NULL;
//     ChronoOn();
//     p3d_setAllDofActive(robotPt);
//     p3d_flatMultiGraph(robotPt, 1);
//     p3d_setAllDofActive(robotPt);
//     p3d_convertFsgToGraph(graph, robotPt->mg->fsg);
//     ChronoTimes(&tu, &ts);
//     ChronoOff();
//     mgTime += tu;
//     XYZ_GRAPH = graph;
//     robotPt->GRAPH = graph;
// //       p3d_print_info_graph(graph);
//     p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
//     //check if there is solution in this graph or not.
//     if (!p3d_graph_to_traj(robotPt)) {
//       //continuer la recherche
//       printf("Je ne trouve pas en mergeant les traj\n");
//       ChronoOn();
//       p3d_delFlatSuperGraph(robotPt, robotPt->mg->fsg);
//       p3d_flatMultiGraph(robotPt, 0);
//       p3d_setAllDofActive(robotPt);
//       p3d_del_graph(graph);
//       graph = p3d_create_graph();
//       p3d_convertFsgToGraph(graph, robotPt->mg->fsg);
//       ChronoTimes(&tu, &ts);
//       ChronoOff();
//       mgTime += tu;
//       XYZ_GRAPH = graph;
//       robotPt->GRAPH = graph;
//       p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
//       if (!p3d_graph_to_traj(robotPt)) {
//         //fonction pour ajouter qu'un noeud et merger après chaque coup.
//         p3d_doIncrementalConstruction(1);
//         printf("Je ne trouve pas en mergeant les traj et tous les noeuds faut enrichir\n");
//         p3d_learn(p3d_get_NB_NODES(), fct_stop, fct_draw);
//         p3d_setAllDofActive(robotPt);
//         graph = XYZ_GRAPH;
//         p3d_print_info_graph(graph);
//         p3d_addStartAndGoalNodeToGraph(qs, qg, NULL, NULL, graph, robotPt);
//         p3d_doIncrementalConstruction(0);
//       }
//     }
//     graph->mgTime += mgTime;
//     graph->time += gTime + graph->mgTime;
//   }
// }


void p3d_globalSuperGraphLearn(void){
  p3d_graph * final = NULL;
  double graphsTime = 0.0, tu = 0.0, ts = 0.0;
  int graphsNodes = 0, graphsEdges = 0;
  p3d_rob * robotPt = XYZ_ROBOT;

  if (!XYZ_GRAPH) final = p3d_create_graph();
  else           final = XYZ_GRAPH;

  for(int j = 0; j < robotPt->mg->nbGraphs; j++){
    p3d_set_user_drawnjnt(robotPt->mg->mgJoints[j]->joints[robotPt->mg->mgJoints[j]->nbJoints - 1]);
    p3d_setMultiGraphAndActiveDof(robotPt, j);
    p3d_globalPDRSequence();
//     CB_global_search_obj(NULL,0);
//     CB_print_obj(NULL,0);
    graphsTime += XYZ_GRAPH->time;
    graphsNodes += XYZ_GRAPH->nnode;
    graphsEdges += XYZ_GRAPH->nedge;
    if(STAT){
      setTotalCountVar(XYZ_GRAPH);
      mergeStat(XYZ_GRAPH->stat, final->stat);
    }
  }

  ChronoOn();
  p3d_setAllDofActive(robotPt);
  p3d_flatMultiGraph(robotPt, 0);
  p3d_setAllDofActive(robotPt);
  p3d_convertFsgToGraph(final, robotPt->mg->fsg);
  ChronoTimes(&tu, &ts);
  ChronoOff();
  final->mgTime += tu;
  final->time += graphsTime;
  XYZ_GRAPH = final;
  robotPt->GRAPH = final;
  p3d_set_user_drawnjnt(-1);
  MY_ALLOC_INFO("After p3d_learn");
  p3d_print_info_graph(final);
  if (STAT){
    final->stat->mgNodes = final->nnode;
    final->nnode = final->stat->planConfAdd;
    final->stat->mgEdges = final->nedge/2;
    final->nedge = final->stat->planEdge*2;
    final->stat->mgTime = final->mgTime;
  }
  printf("Graphs Nodes = %d\n", graphsNodes);
  printf("Graphs Edges = %d\n", graphsEdges);
  printf("SG merge time = %f\n", final->mgTime);
}
#endif

static void p3d_globalPDRSequence(void){
  int nbTry = p3d_get_NB_TRY();
  p3d_set_is_visibility_discreet(0);
  p3d_set_test_reductib(0);
  p3d_set_cycles(0);
  CB_global_search_obj(NULL,0);
  p3d_set_cycles(1);
  p3d_set_is_visibility_discreet(1);
  p3d_set_test_reductib(1);
  p3d_set_NB_TRY(((int)(nbTry/20)));
  CB_global_search_obj(NULL,0);
  p3d_set_NB_TRY(nbTry);
  p3d_set_is_visibility_discreet(0);
  p3d_set_test_reductib(0);
  p3d_set_cycles(0);
}

// /****************************************************************************/
// /** \brief Find all the series from the history.
//  \param *tabi history table
//  \param **series table to return the series
//  \param nbShoot number max of shoots
//  \return number of series found and a table (series) containing all series
//  */
// /****************************************************************************/
// int getSeries(int* tabi, int** series, int nbShoot) {
//   int i = 0, nbSeries = 0, inSeries = 0;
// 
//   for (i = 0; i < nbShoot; i++) {
//     if (!inSeries && !tabi[i]) {  //si on n'est pas dans une serie et qu'on tombe sur un 0 commencer la sÃ©rie
//       series[nbSeries][1] = i;//point de depart de la serie
//       series[nbSeries][0] += 2;//incrementer le nombre d'elements dans la serie (on commence a -1)
//       inSeries = 1;
//     } else
//       if (inSeries) {  //si on est dans une serie
//         if (!tabi[i]) {  //et que la serie continue
//           series[nbSeries][0]++;
//         } else { //si la serie s'arrete
//           series[nbSeries][2] = i;//point de fin de la serie
//           inSeries = 0;
//           nbSeries++;
//         }
//       }
//   }
//   if (inSeries) {
//     series[nbSeries][2] = i;//point de fin de la serie
//     nbSeries++;
//   }
//   return nbSeries;
// }
// /****************************************************************************/
// /** \brief Find the biggest serie
//  \param **series table containing all series
//  \param nbSeries number of elements in series
//  \return number of series
//  */
// /****************************************************************************/
// int getSizeOfBigestSerie(int** series, int nbSeries) {
//   int i = 0, best = 0;
//   for (i = 0; i < nbSeries; i++) {
//     best = series[i][0] > best ? series[i][0] : best;
//   }
//   return best;
// }
// 
// /****************************************************************************/
// /** \brief Find the number of series given a size
//  \param **series table containing all series
//  \param nbSeries number of elements in series
//  \param serieSize size of the serie to find
//  \return number of series
//  */
// /****************************************************************************/
// int getNbSeries(int** series, int nbSeries, int serieSize) {
//   int i = 0, n = 0;
//   for (i = 0; i < nbSeries; i++) {  //pour toutes les series
//     if (series[i][0] < serieSize) {   //si la serie est plus petite que la taille qu'on veut
//       //do nothing
//     } else
//       if (series[i][0] == serieSize) {  //si elle est egale
//         n++;
//       } else
//         if (series[i][0] > serieSize) {  //si elle est plus grande
//           n += series[i][0] - serieSize + 1;
//         }
//   }
//   return n;
// }

// /****************************************************************************/
// /** \brief Get sub history picking the k last guardians
//  \param *history table containing the complete history shoot
//  \param *subHistory table to return the sub history
//  \param guardians number of guardian to take in account (k)
//  \param historySize the size of the history
//  \return size of the sub history
//  */
// /****************************************************************************/
// int getsubHistory(int* history, int* subHistory, int guardians, int historySize) {
//   int i = 0, j = 0, cnt = 0;
//   if ((historySize > 1) && (history[historySize-1] == 1)){
//     i = historySize - 2;
//   }else{
//     i = historySize - 1;
//   }
//   for (; (i >= 0) && (cnt < guardians); i--) {
//     if (history[i] == 1) {
//       cnt++;
//     }
//   }
//   i++;
//   for (j = i, cnt = 0; j < historySize; j++, cnt++) {
//     subHistory[cnt] = history[j];
//   }
//   return historySize - i;
// }

// /****************************************************************************/
// /** \brief Compute the real coverage (brute force)
//  \param nbShoot number of configuration to sample
//  \return the real covreage
//  */
// /****************************************************************************/
// static double p3d_real_coverage(int nbShoot){
//   int visibleNode = 0, i = 0, j = 0;
//   double dist = 0.0;
//   p3d_list_node *listNode = XYZ_GRAPH->nodes;
//   p3d_node *newNode;
// 
//   for(i = 0; i < nbShoot; i++){
//     newNode = p3d_APInode_shoot(XYZ_GRAPH);
//     listNode = XYZ_GRAPH->nodes;
//     for(j = 0; (j < XYZ_GRAPH->nnode) && listNode != NULL; j++, listNode = listNode->next){
//       if(p3d_APInode_linked(XYZ_GRAPH,newNode,listNode->N,&dist)){
//         visibleNode++;
//         break;
//       }
//     }
//     p3d_APInode_desalloc(XYZ_GRAPH,newNode);
//   }
//   return ((double)visibleNode) / ((double)nbShoot);
// }


// /****************************************************************************/
// /** \brief Store information history for Prms
//  \param nodeStatus the status of the node sampled (0 = failed, 1 = insertion successful in the graph)
//  \param ope operation (-2 = free, -1 = allocate, 0 = init, 1 = add, 2 = print)
//  \return True if the edge is visible from q0 False otherwise.
//  */
// /****************************************************************************/
// void p3d_prm_history(int nodeStatus, int ope) {
//   int j = 0, k = 0, seriesSize = 0, nbSeries = 0, biggestSerie = 0, nbk = 500, subHistorySize = 0;
//   int **series, *subHistory;
//   static int i = 0, nbFail = 0, nbSuccess = 0, currentNtry = 0, nbShoot = 0;
//   static int *shootHistory, *nbSuccessTab, *nbFailTab;
//   double couvK = 0.0;
//   static double *tabi, *tabiGardien, *couvBiggestSerie, *couvReal, *couvMaximale, *couvNtry, *couvBiggestSerieGardien, *couvRealGardien, *couvMaximaleGardien, *couvNtryGardien, *nbFailTabGardien, **couvKFail;
//   char tmp[2];
//   gnuplot_ctrl *couverture, *couvertureGardien;
//   switch (ope) {
//     case -2: { //free all tables
//       free(shootHistory);
//       free(nbSuccessTab);
//       free(nbFailTab);
//       free(tabi);
//       free(tabiGardien);
//       free(couvBiggestSerie);
//       free(couvReal);
//       free(couvMaximale);
//       free(couvNtry);
//       free(couvBiggestSerieGardien);
//       free(couvMaximaleGardien);
//       free(couvNtryGardien);
//       free(nbFailTabGardien);
//       for (i = 0; i < nbk; i++) {
//         free(couvKFail[i]);
//       }
//       free(couvKFail);
//       break;
//     }
//     case -1: { //allocate all tables
//       nbShoot = p3d_get_NB_NODES()*10;
//       shootHistory = (int *) malloc(nbShoot * sizeof(int));       //Historique
//       nbSuccessTab = (int *) malloc(nbShoot * sizeof(int));       //Tableau des success
//       nbFailTab = (int *) malloc(nbShoot * sizeof(int));       //Tableau des fail
//       tabi = (double *) malloc(nbShoot * sizeof(double));       //Tableau des i (uniqument pour les courbes)
//       tabiGardien = (double *) malloc(nbShoot * sizeof(double));       //Tableau des i pour les gardiens (uniqument pour les courbes)
//       couvBiggestSerie = (double *) malloc(nbShoot * sizeof(double));       //Tableau de la couverture de la plus grandeSerie
//       couvReal = (double *) malloc(nbShoot * sizeof(double));       //Tableau de la couverture reelle
//       couvMaximale = (double *) malloc(nbShoot * sizeof(double));       //Tableau contenant le max des Ck
//       couvNtry = (double *) malloc(nbShoot * sizeof(double));       //Tableau de l'evolution de la couverture calculee par les ntry sans les remetre a zero lors des success
//       couvBiggestSerieGardien = (double *) malloc(nbShoot * sizeof(double));       //Tableau de la couverture de la plus grandeSerie
//       couvRealGardien = (double *) malloc(nbShoot * sizeof(double));       //Tableau de la couverture reelle
//       couvMaximaleGardien = (double *) malloc(nbShoot * sizeof(double));       //Tableau contenant le max des Ck
//       couvNtryGardien = (double *) malloc(nbShoot * sizeof(double));       //Tableau de l'evolution de la couverture calculee par les ntry sans les remetre a zero lors des success
//       nbFailTabGardien = (double *) malloc(nbShoot * sizeof(double));
//       couvKFail = (double **) malloc((nbk) * sizeof(double*));         //matrice de stockage des couvertures estimÃ©es pour Nfail
//       for (j = 0; j < nbk; j++) {
//         couvKFail[j] = (double *) malloc(nbShoot * sizeof(double));
//       }
//       break;
//     }
//     case 0: { //init all tables
//       for (j = 0; j < nbShoot; j++) {
//         shootHistory[j] = -1;
//         nbSuccessTab[j] = 0;
//         nbFailTab[j] = 0;
//         tabi[j] = 0;
//         tabiGardien[j] = 0;
//         couvBiggestSerie[j] = 0;
//         couvReal[j] = 0;
//         couvMaximale[j] = 0;
//         couvNtry[j] = 0;
//         couvBiggestSerieGardien[j] = 0;
//         couvRealGardien[j] = 0;
//         couvMaximaleGardien[j] = 0;
//         couvNtryGardien[j] = 0;
//         nbFailTabGardien[j] = -1;
//       }
//       for (j = 0; j < nbk; j++) {
//         for (k = 0; k < nbShoot; k++) {
//           couvKFail[j][k] = 0;
//         }
//       }
//       break;
//     }
//     case 1: { //new node added or failed
//       subHistory = (int *) malloc(nbShoot * sizeof(int));
//       series = (int **) malloc((nbShoot / 2) * sizeof(int*));
//       for (j = 0; j < nbShoot / 2; j++) {
//         series[j] = (int *) malloc(3 * sizeof(int));
//       }
//       for(j = 0; j < nbShoot; j++) {
//         subHistory[j] = -1;
//       }
//       for (j = 0; j < nbShoot / 2; j++) {
//         for (k = 0; k < 3; k++) {
//           series[j][k] = -1;
//         }
//       }
//       tabi[i] = i;
// //       printf("%d,",tabi[i]);
//       //remplissage des fail success
//       if (nodeStatus == 0) {
//         nbFail++;
//         shootHistory[i] = 0;
//         if (i > 0) {
//           nbFailTab[i] = nbFailTab[i-1] + 1;
//         }
//       } else {
//         nbSuccessTab[nbSuccess] = i;
//         nbSuccess++;
//         shootHistory[i] = 1;
//         nbFailTab[i] = 0;
//       }
// 
//       if (currentNtry < nbFailTab[i]) {
//         currentNtry = nbFailTab[i];
//       }
//       if (currentNtry != 0) {
//         couvNtry[i] = 1.0 - 1.0 / currentNtry;
//       }
//       //Calcul de Cbig et Creal
//       subHistorySize = getsubHistory(shootHistory,subHistory, 1 , i + 1);//on prend le sous historique
//       seriesSize = getSeries(subHistory, series, subHistorySize);//on sort toutes les series qu'on a
//       biggestSerie = getSizeOfBigestSerie(series, seriesSize);//la taille de la serie la plus longue
//       nbSeries = getNbSeries(series, seriesSize, biggestSerie);//Calcul du nombre d'occurence de la plus grande serie
//       couvBiggestSerie[i] = (double)(pow((double) nbSeries / (subHistorySize - biggestSerie + 1.0), 1.0 / biggestSerie));//Calcul de la couverture avec la plus grande serie
//       couvReal[i] = p3d_real_coverage(1000);//couverture rÃ©elle
//       printf("real = %f\n", couvReal[i]);
// 
//       //calcul des Ck et CMax
//       if (i > 0) {
//         couvMaximale[i] = couvMaximale[i-1];
//       }
//       for (j = 0; j < biggestSerie; j++) {
//         nbSeries = getNbSeries(series, seriesSize, j);  //calcul du nombre d'occurence de la serie de taille j
//         couvK = (double)(pow((double) nbSeries / (subHistorySize - j + 1.0), 1.0 / j));//calcul de la couverture de Ck
//         if (j < nbk) {
//           couvKFail[j][i] = couvK;
//         }
//         if (couvMaximale[i] < couvK) {
//           couvMaximale[i] = couvK;
//         }
//       }
//       i++;
//       for (j = 0; j < nbShoot / 2; j++) {
//         free(series[j]);
//       }
//       free(series);
//       free(subHistory);
//       break;
//     }
//     case 2: { //print informations
//       couverture = gnuplot_init();//Graphiques des couvertures en fonction du nombre de tirages
//       gnuplot_setstyle(couverture, "lines");
// //       gnuplot_setlogscale(couverture,"x");
// //       gnuplot_setrange(couverture, "y", 0.9, 1);
//       couvertureGardien = gnuplot_init();//Graphique des couvertures en fonction du nombre de gardiens
//       gnuplot_setstyle(couvertureGardien, "lines");
//       gnuplot_setlogscale(couvertureGardien, "x");
// //       gnuplot_setrange(couvertureGardien, "y", 0.9, 1);
// 
//       gnuplot_plot_xy(couverture, tabi, couvReal, i, "Reelle");
//       gnuplot_plot_xy(couverture, tabi, couvBiggestSerie, i, "CBig");
//       gnuplot_plot_xy(couverture, tabi, couvMaximale, i, "CMax");
//       gnuplot_plot_xy(couverture, tabi, couvNtry, i, "ntry");
// 
//       for (i = 0; i < nbSuccess; i++) {
//         tabiGardien[i] = i + 1;
//         couvBiggestSerieGardien[i] = couvBiggestSerie[nbSuccessTab[i]];
//         couvRealGardien[i] = couvReal[nbSuccessTab[i]];
//         couvMaximaleGardien[i] = couvMaximale[nbSuccessTab[i]];
//         couvNtryGardien[i] = couvNtry[nbSuccessTab[i]];
//         if (i > 0) {
//           if (nbFailTab[nbSuccessTab[i] - 1] != 0) {
//             nbFailTabGardien[i] = 1.0 - 1.0 / (double) nbFailTab[(int) nbSuccessTab[i] - 1];
//             printf("i: %d, nbFail = %d, Cgardien = %f\n", i, nbFailTab[nbSuccessTab[i] - 1], nbFailTabGardien[i]);
//           } else {
//             nbFailTabGardien[i] = nbFailTabGardien[i-1];
//           }
//         } else {
//           nbFailTabGardien[i] = 0;
//         }
//       }
//       gnuplot_plot_xy(couvertureGardien, tabiGardien, couvRealGardien, nbSuccess, "ReelleG");
//       gnuplot_plot_xy(couvertureGardien, tabiGardien, couvBiggestSerieGardien, nbSuccess, "CBigG");
//       gnuplot_plot_xy(couvertureGardien, tabiGardien, couvMaximaleGardien, nbSuccess, "CMaxG");
//       //    gnuplot_plot_xy(couvertureGardien, tabi, couvNtryGardien, nbSuccess, "ntry");
//       gnuplot_plot_xy(couvertureGardien, tabiGardien, nbFailTabGardien, nbSuccess, "nfailG");
// 
//       printf("nbSucess = %d, nbFail = %d\n", nbSuccess, nbFail);
// 
//       fgets(tmp, 10, stdin);
//       gnuplot_close(couverture);
//       gnuplot_close(couvertureGardien);
//       break;
//     }
//   }
// }


// struct pthread_data{
//   int nMax;
//   int inode;
//   p3d_graph * G;
//   int (*fct_stop)(void);
//   void (*fct_draw)(void);
// };
// 
// 
// 
// void* p3d_learnThread(void* thread_data){
//   int inode = 0, ADDED = 0;
//   struct pthread_data * tdata = (struct pthread_data *) thread_data;
//   int NMAX = tdata->nMax;
//   int fail = 1;
//   p3d_graph * G = tdata->G;
//   
//   while (inode < NMAX) {
//     /* Call basic PRM or Visibility method */
//     switch (p3d_get_MOTION_PLANNER()) {
//       case 1:
//         ADDED = p3d_add_basic_node(G, tdata->fct_stop, &fail);
//         break;
//       case 2:
//         ADDED = p3d_add_isolate_or_linking_node(G, tdata->fct_stop, tdata->fct_draw,
//                                                 &fail, P3D_ISOLATE_LINKING);
//         break;
//       case P3D_ALL_PRM:
//         ADDED = p3d_add_all_prm_node(G, tdata->fct_stop);
//         break;
//       default:
//         PrintInfo(("p3d_learn : ERREUR : pas de planificateur global...\n"));
//         return NULL;
//     }
// 
//     if (ADDED) {
//       inode = inode + 1;
//       inode += ADDED;
//       if (tdata->fct_draw)(*(tdata->fct_draw))();
//     } else {
//       PrintInfo(("p3d_learn : ECHEC a l'insertion d'un noeud\n"));
//       break;
//     }
// 
//     if (tdata->fct_stop) {
//       if (!(*(tdata->fct_stop))()) {
//         PrintInfo(("basic PRM building canceled\n"));
//         break;
//       }
//     }
//   }
//   tdata->inode = inode;
//   return NULL;
// }
// 
// 
// /***********************************************************/
// /* Fonction creant un roadmap sur l'environnement courant, */
// /* dans le graphe courant avec un nombre de noeuds fixe    */
// /* In : le nombre de noeuds                                */
// /* Out :                                                   */
// /***********************************************************/
// 
// void p3d_learnMultiThread(int NMAX, int (*fct_stop)(void), void (*fct_draw)(void)) {
//   p3d_graph *G;
// #ifdef MULTIGRAPH
//   p3d_graph *final = NULL;
//   int test = 0;
// #endif
//   int inode, ADDED;
//   double tu, ts;
// 
// 
//   ChronoOn();
// 
//   if (!XYZ_GRAPH) G = p3d_create_graph();
//   else           G = XYZ_GRAPH;
// #ifdef MULTIGRAPH
//   final = G;
// #endif
// 
//   inode = 0;
//   p3d_set_planning_type(P3D_GLOBAL);
// 
//   threads
//   struct pthread_data ** tdata = MY_ALLOC (struct pthread_data *, XYZ_ROBOT->mg->nbGraphs);
//   pthread_t* thTab = MY_ALLOC(pthread_t, XYZ_ROBOT->mg->nbGraphs);
// 
//   for(int i = 0; i < XYZ_ROBOT->mg->nbGraphs; i++){
//     tdata[i] =  MY_ALLOC (struct pthread_data ,1);
//     tdata[i]->G = p3d_setMultiGraphAndActiveDof(XYZ_ROBOT, i);
//     tdata[i]->nMax = NMAX;
//     tdata[i]->fct_stop = fct_stop;
//     tdata[i]->fct_draw = fct_draw;
//     if (pthread_create(&(thTab[i]), NULL, p3d_learnThread, tdata[i])) {
//       perror("pthread_create"); 
//       exit(EXIT_FAILURE);
//     }
//   }
//   for(int i = 0; i < XYZ_ROBOT->mg->nbGraphs; i++){
//     if (pthread_join(thTab[i], NULL)) 
//         perror("pthread_join");
//   }
//   for(int i = 0; i < XYZ_ROBOT->mg->nbGraphs; i++ ){
//     MY_FREE(tdata[i], struct pthread_data, 1);
//   }
//   MY_FREE(tdata, struct pthread_data *, XYZ_ROBOT->mg->nbGraphs);
//   MY_FREE(thTab, pthread_t, XYZ_ROBOT->mg->nbGraphs);
// #ifdef MULTIGRAPH
//   if(p3d_get_multiGraph()){
//     p3d_setAllDofActive(XYZ_ROBOT);
//     p3d_flatMultiGraph(XYZ_ROBOT);
//     p3d_setAllDofActive(XYZ_ROBOT);
//     p3d_convertFsgToGraph(final, XYZ_ROBOT->mg->fsg);
//     XYZ_GRAPH = final;
//     XYZ_ROBOT->GRAPH = final;
//     G = final;
//   }
// #endif
//   p3d_set_planning_type(P3D_NONE);
//   PrintInfo(("Pour la creation de %d noeuds : ", inode));
//   ChronoTimes(&tu, &ts);
//   G->time = G->time + tu;
//   ChronoPrint("");
//   ChronoOff();
//   MY_ALLOC_INFO("After p3d_learn");
//   p3d_print_info_graph(G);
// 
//   
//   MY_FREE(tdata, struct pthread_data, 1);
//   
// }

