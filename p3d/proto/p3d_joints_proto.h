/*
 * Copyright (c) 2001-2014 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution  and  use  in  source  and binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 * THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
 * WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
 * MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
 * ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
 * WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                                  
 *
 * SimÃ©on, T., Laumond, J. P., & Lamiraux, F. (2001). 
 * Move3d: A generic platform for path planning. In in 4th Int. Symp.
 * on Assembly and Task Planning.
 */
/*
 *   This file was automatically generated by version 1.7 of cextract.
 *   Manual editing not recommended.
 *
 *   Created: Wed Jun 23 14:30:05 2004
 */
#ifndef __CEXTRACT__

extern p3d_jnt * p3d_robot_dof_to_jnt ( p3d_rob * robotPt, int i_robot, int * i_joint );
extern int p3d_robot_user_dof_to_dof ( p3d_rob * robotPt, int i_user_dof );
extern int p3d_jnt_get_dof_is_angular ( p3d_type_joint type, int i_dof );
extern int p3d_jnt_is_dof_angular ( p3d_jnt * jntPt, int i_dof );
extern int p3d_jnt_is_dof_linear ( p3d_jnt * jntPt, int i_dof );
extern int p3d_jnt_compute_is_dof_circular(p3d_jnt * jntPt, int i_dof);
inline bool p3d_jnt_is_dof_circular(p3d_jnt * jntPt, int i_dof)
{
  return(jntPt->dof_data[i_dof].circular);
}
extern const char * p3d_jnt_get_dof_name ( p3d_jnt * jntPt, int i_dof );
extern const char * p3d_jnt_get_only_dof_name ( p3d_type_joint type, int i_dof );
extern void p3d_jnt_set_name ( p3d_jnt * jntPt, const char * name );
extern double p3d_jnt_get_dof ( p3d_jnt * jntPt, int i_dof );
extern double p3d_jnt_get_dof_deg ( p3d_jnt * jntPt, int i_dof );
extern int p3d_jnt_get_dof_is_user ( p3d_jnt * jntPt, int i_dof );
extern int p3d_jnt_get_dof_is_active_for_planner(p3d_jnt * jntPt, int i_dof);
extern int p3d_jnt_get_dof_is_modified ( p3d_jnt * jntPt, int i_dof );
extern double p3d_jnt_get_dof_v0 ( p3d_jnt * jntPt, int i_dof );
extern double p3d_jnt_get_dof_v0_deg ( p3d_jnt * jntPt, int i_dof );
extern void p3d_jnt_get_dof_axis ( p3d_jnt * jntPt, int i_dof, p3d_vector3 axe );
extern void p3d_jnt_get_dof_cur_axis ( p3d_jnt * jntPt, int i_dof, p3d_vector3 axe );
extern void p3d_jnt_get_dof_cur_axis_before ( p3d_jnt * jntPt, int i_dof, p3d_vector3 axe );
extern void p3d_jnt_get_dof_bounds ( p3d_jnt * jntPt, int i_dof, double *vmin, double *vmax );
extern void p3d_jnt_get_dof_bounds_deg ( p3d_jnt * jntPt, int i_dof, double *vmin, double *vmax );
extern void p3d_jnt_get_dof_rand_bounds ( p3d_jnt * jntPt, int i_dof, double *vmin, double *vmax );
extern void p3d_jnt_get_dof_rand_bounds_deg ( p3d_jnt * jntPt, int i_dof, double *vmin, double *vmax );
extern void p3d_jnt_get_point ( p3d_jnt * jntPt, p3d_point * pointPt );
extern void p3d_jnt_get_vect_point ( p3d_jnt * jntPt, p3d_vector3 pos );
extern void p3d_jnt_get_cur_vect_point ( p3d_jnt * jntPt, p3d_vector3 pos );
extern void p3d_jnt_get_cur_vect_point_before ( p3d_jnt * jntPt, p3d_vector3 pos );
extern int p3d_jnt_is_with_object ( p3d_jnt * jntPt );
extern void p3d_jnt_set_dof ( p3d_jnt * jntPt, int i_dof, double val );
extern void p3d_jnt_set_dof_deg ( p3d_jnt * jntPt, int i_dof, double val );
extern void p3d_jnt_set_dof_is_user ( p3d_jnt * jntPt, int i_dof, int flag );
extern void p3d_jnt_set_dof_is_active_for_planner(p3d_jnt * jntPt, int i_dof, int flag);
extern void p3d_jnt_set_is_user ( p3d_jnt * jntPt, int flag );
extern int p3d_jnt_get_is_active_for_planner(p3d_jnt * jntPt);
extern void p3d_jnt_set_is_active_for_planner(p3d_jnt * jntPt, int flag);
extern void p3d_jnt_set_dof_is_modified ( p3d_jnt * jntPt, int i_dof, int val );
extern void p3d_jnt_force_update ( p3d_jnt * jntPt );
extern void p3d_jnt_set_dof_v0 ( p3d_jnt * jntPt, int i_dof, double val );
extern void p3d_jnt_set_dof_v0_deg ( p3d_jnt * jntPt, int i_dof, double val );
extern void p3d_jnt_set_dof_bounds ( p3d_jnt * jntPt, int i_dof, double vmin, double vmax );
extern void p3d_jnt_set_dof_bounds_deg ( p3d_jnt * jntPt, int i_dof, double vmin, double vmax );
extern void p3d_jnt_set_dof_rand_bounds ( p3d_jnt * jntPt, int i_dof, double vmin, double vmax );
extern void p3d_jnt_set_dof_rand_bounds_deg ( p3d_jnt * jntPt, int i_dof, double vmin, double vmax );
extern void p3d_jnt_update_rel_pos_object(p3d_jnt * jntPt, p3d_obj * objPt);
extern int p3d_jnt_set_object ( p3d_jnt * jntPt, p3d_obj * objPt );
extern void p3d_jnt_stay_within_dist ( p3d_stay_within_dist_data * prev_data, p3d_jnt * jntPt, p3d_stay_within_dist_data * data, double * distance, configPt q_init, configPt q_max_param, double max_param, double * reach_param );
extern double p3d_GetWeightRotations(void);
extern void p3d_SetWeightRotations(double RotationWeight);
extern double p3d_jnt_calc_dof_dist ( p3d_jnt * jntPt, int i_dof, configPt q_init, configPt q_end );
extern double p3d_jnt_calc_dof_dist_2 ( p3d_jnt * jntPt, int i_dof, configPt q_init, configPt q_end );
extern double p3d_jnt_calc_dof_value ( p3d_jnt * jntPt, int i_dof, configPt q_init, configPt q_end, double alpha );
extern void p3d_jnt_calc_jnt_mat ( p3d_jnt * jntPt );
extern int p3d_jnt_calc_mat_pos ( p3d_link_between_joint * link_jntPt );
extern void p3d_jnt_set_mat_pos ( p3d_jnt * jntPt, p3d_matrix4 * abs_pos );
extern int p3d_jnt_calc_mat_pos_and_jac ( p3d_link_between_joint * link_jntPt );
extern void p3d_jnt_set_mat_pos_and_jac ( p3d_jnt * jntPt, p3d_matrix4 * abs_pos );
extern void p3d_jnt_clean_update ( p3d_jnt * jntPt );
extern p3d_jnt * p3d_jnt_create_common ( p3d_matrix4 pos );
extern p3d_jnt * p3d_jnt_create ( p3d_type_joint type, p3d_matrix4 pos, double * v, double * vmin, double * vmax, double * vmin_rand, double * vmax_rand, double * velocity_max, double * torque_max, double * param );
extern p3d_jnt * p3d_jnt_create_deg ( int type, p3d_matrix4 pos, double * v, double * vmin, double * vmax, double * vmin_rand, double * vmax_rand, double * velocity_max, double *acceleration_max, double *jerk_max, double * torque_max, double * param );
extern void p3d_jnt_get_nb_param ( p3d_type_joint type, int * nb_dof, int * nb_param );
extern void p3d_jnt_scale ( p3d_jnt * jntPt, double scale );
extern void p3d_jnt_change_pos0 ( p3d_jnt * jntPt, p3d_matrix4 pos0 );
extern void p3d_jnt_attach_to_jnt ( p3d_jnt * jnt_prevPt, p3d_jnt * jntPt );
extern void p3d_jnt_attachment ( p3d_jnt * jnt1Pt, p3d_jnt * jnt2Pt, p3d_matrix4 rel_pos, int flag_prev );
extern void p3d_jnt_deattach_jnt ( p3d_jnt * jntPt1, p3d_jnt * jntPt2 );
extern void p3d_jnt_destroy ( p3d_jnt * jntPt );
extern int p3d_jnt_object_after_joint ( p3d_jnt * jntPt );
//start path deform
extern void p3d_jnt_stay_within_sphere ( p3d_stay_within_dist_data * prev_data, p3d_jnt * jntPt, p3d_stay_within_dist_data * data, double * distance, double * reach_param );
extern void p3d_jnt_set_is_active_for_planner2(p3d_jnt * jnt, int flag);
//end path deform
extern double p3d_jnt_compute_max_distance_body_vertex(p3d_obj* body);

#endif /* __CEXTRACT__ */
