#include "P3d-pkg.h"

/*
 * Local computation constants and macros
 */
#define LOCAL_COMPUTATION_EPSILON (1e-9)
#define PI 3.14159265358979323846
#define SQR(x) ((x)*(x))
/* #define MAX(a,b) (((a) > (b)) ? (a) : (b)) */
/* #define MIN(a,b) (((a) < (b)) ? (a) : (b)) */
/* #define SIGN(x) (((x) < 0 ) ? (-1) : (1)) */
/* #define ABS(x) (((x) > 0 ) ? (x) : -(x)) */
/* #define SQR(x) ((x) * (x)) */
/* #define CUBE(x) (SQR(x) * (x)) */


static int compute_ik_justin_arm_wrist (p3d_matrix4 tldofTarget, int sjnt, int r2, int r4,
                                 double a, double b, double c,
                                 double *dOut, double *eOut, double *fOut);
static int justin_a(double *aOut, double A14, double A24, double r2, double r4,int jntpos,
                                 p3d_rob* rob, int flagA);
static int justin_c(double *cOut, double a,double A14, double A24, double A34, double r2, 
                                 double r4, int jntpos, p3d_rob* rob, int flagC);
static int justin_b(double *bOut, double a, double r2, double r4, double A14, double A24,
                                 double A34,int jntpos, p3d_rob* rob, int flagB);
/*
 * Compute atan2
 */

static double
arm_atan2(double y, double x) {
  return ((x == 0.) ? ((y == 0. ) ? 0. : SIGN(y) * M_PI / 2.) : atan2(y , x));
}



/*******************************************************************************/

int compute_all_ik_R6_arm(p3d_rob *robotPt, p3d_matrix4 Tbase, p3d_matrix4 Tgrip, double **q_list) {
  double a2,r4,r7;
  int no_sol;

  /* SUPPOSE THAT DATA ARE STORED IN THE FIRST CNTRT OF THE ROBOT !!! */
  /* (-> TO BE MODIFIED) */
  a2 = robotPt->cntrt_manager->cntrts[0]->argu_d[0];
  r4 = robotPt->cntrt_manager->cntrts[0]->argu_d[1];
  r7 = robotPt->cntrt_manager->cntrts[0]->argu_d[2];

  no_sol = TRUE;
  if(!compute_inverse_kinematics_R6_arm(q_list[0],Tgrip,Tbase,a2,r4,r7,1,1,1))
    q_list[0] = NULL;     /* forward-up-flip */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[1],Tgrip,Tbase,a2,r4,r7,1,1,-1))
    q_list[1] = NULL;     /* forward-up-flop */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[2],Tgrip,Tbase,a2,r4,r7,1,-1,1))
    q_list[2] = NULL;     /* forward-down-flip */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[3],Tgrip,Tbase,a2,r4,r7,1,-1,-1))
    q_list[3] = NULL;     /* forward-down-flop */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[4],Tgrip,Tbase,a2,r4,r7,-1,1,1))
    q_list[4] = NULL;     /* backward-up-flip */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[5],Tgrip,Tbase,a2,r4,r7,-1,1,-1))
    q_list[5] = NULL;     /* backward-up-flop */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[6],Tgrip,Tbase,a2,r4,r7,-1,-1,1))
    q_list[6] = NULL;     /* backward-down-flip */
  else
    no_sol = FALSE;
  if(!compute_inverse_kinematics_R6_arm(q_list[7],Tgrip,Tbase,a2,r4,r7,-1,-1,-1))
    q_list[7] = NULL;     /* backward-down-flop */
  else
    no_sol = FALSE;

  return(!no_sol);
}



/*
 * Compute inverse kinematics of 6R arm
 *
 * ( function adapted from /usr/local/robots/gt6a/kinematics/ )
 *
 * Output: q
 * Inputs: grip, kinematic_params, e1, e3, e5...
 *
 */

int compute_inverse_kinematics_R6_arm (double *q,
                                       p3d_matrix4 Tgrip,  // wTg
                                       p3d_matrix4 Tbase,  // wTb
                                       // p3d_R6_arm_kin_param *kinematic_params,
                                       double a2, double r4, double r7,
                                       int e1, int e3, int e5) {
  p3d_matrix4 bTg,Tinv;
  p3d_vector3 v,vxgrip,vygrip,vzgrip;
  p3d_vector3 posgrip;
  double d[12];
  double c1, c2, c3, c4, c5, c6, c23;
  double s1, s2, s3, s4, s5, s6, s23;
  double px, py, pz;
  /*   double r4 = kinematic_params->r[4 - 1]; */
  /*   double a2 = kinematic_params->a[2]; */
  /*   double r7 = kinematic_params->grip_to_q6_dis; */

  /* transformation from base to grip */
  /* wTg = wTb * bTg  ->  bTg = inv(wTb) * wTg */
  p3d_matInvertXform(Tbase, Tinv);
  p3d_mat4Mult(Tinv,Tgrip,bTg);

  /* vectors */
  v[0] = bTg[0][0];
  v[1] = bTg[1][0];
  v[2] = bTg[2][0];
  p3d_vectNormalize(v,vxgrip);
  v[0] = bTg[0][1];
  v[1] = bTg[1][1];
  v[2] = bTg[2][1];
  p3d_vectNormalize(v,vygrip);
  v[0] = bTg[0][2];
  v[1] = bTg[1][2];
  v[2] = bTg[2][2];
  p3d_vectNormalize(v,vzgrip);
  posgrip[0] = bTg[0][3];
  posgrip[1] = bTg[1][3];
  posgrip[2] = bTg[2][3];

  /* compute position of the fourth joint */
  px = posgrip[0] - r7 * vzgrip[0];
  py = posgrip[1] - r7 * vzgrip[1];
  pz = posgrip[2] - r7 * vzgrip[2];

  /* filter */
  if(ABS(px) < LOCAL_COMPUTATION_EPSILON) px = 0.0;
  if(ABS(py) < LOCAL_COMPUTATION_EPSILON) py = 0.0;
  if(ABS(pz) < LOCAL_COMPUTATION_EPSILON) pz = 0.0;



  d[11] = e1 * sqrt(SQR(px) + SQR(py));

  if (ABS(d[11]) < LOCAL_COMPUTATION_EPSILON) {
    /*     printf("->arm_kinematic_computation: Singularity!\n"); */
    return 0;
  } else {
    c1 = px / d[11];
    s1 = py / d[11];
    q[0] = arm_atan2 (s1, c1);
    s3 = (SQR(d[11]) + SQR(pz) - SQR(r4) - SQR(a2)) / 2. / a2 / r4;
    c3 = e3 * sqrt(1 - SQR(s3));

    if (s3 > 1) {
      /*       printf("->arm_kinematic_computation: position is not accessible!\n"); */
      return 0;
    } else {
      q[2] = arm_atan2(s3, c3);
      s2 = ( r4 * c3 * d[11] + (r4 * s3 + a2) * pz) / (SQR(d[11]) + SQR(pz));
      c2 = (-r4 * c3 * pz + (r4 * s3 + a2) * d[11]) / (SQR(d[11]) + SQR(pz));
      q[1] = arm_atan2(s2, c2);
      s23 = (d[11] - a2 * c2) / r4;
      c23 = (-pz + a2 * s2) / r4;
      d[10] = c1 * vzgrip[0] + s1 * vzgrip[1];
      d[8] = s1 * vzgrip[0] - c1 * vzgrip[1];
      d[9] = c1 * vxgrip[0] + s1 * vxgrip[1];
      d[7] = s1 * vxgrip[0] - c1 * vxgrip[1];
      d[6] = c23 * d[10] + s23 * vzgrip[2];
      c5 = s23 * d[10] - c23 * vzgrip[2];
      d[5] = c23 * d[9] + s23 * vxgrip[2];
      d[4] = s23 * d[9] - c23  * vxgrip[2];
      s5 = e5 * sqrt(SQR(d[6]) + SQR(d[8]));

      q[4] = arm_atan2(s5, c5);

      if (ABS(s5) < LOCAL_COMPUTATION_EPSILON) {
        /*  printf("->arm_kinematic_computation: Singularity!\n"); */
        return 0;
      } else {
        c4 = d[6] / s5;
        s4 = d[8] / s5;
        q[3] = arm_atan2(s4, c4);
        d[3] = c4 * d[5] + s4 * d[7];
        s6 = - s4 * d[5] + c4 * d[7];
        c6 = c5 * d[3] - s5 * d[4];
        q[5] = arm_atan2(s6, c6);

        /* due to the non-correspondence of models */
        /* we need to modify values */
        q[1] -= M_PI/2;
        q[2] -= M_PI/2;
        // modif Juan (for model 6R_arm)
        if(((q[3] > 0.0) && (q[5] > 0.0)) ||
            ((q[3] < 0.0) && (q[5] < 0.0)) ||
            ((q[3] == 0.0) && (q[5] == M_PI)) ||
            ((q[3] == M_PI) && (q[5] == 0.0))) {
          q[5] += M_PI;
          if(q[5] > M_PI)
            q[5] -= 2*M_PI;
        }

        /* Ok */
        return 1;
      }
    }
  }
}


/*******************************************************************************/
/* CT Bot                                                                      */
/*******************************************************************************/

/**
 * %  Resolution du modele geometrique du robot a partir d'une
 * %  configuration spatiale F=[FX,FY,FZ] (saisie aiguille) Z=[Zx,Zy,Zz] 
(droite support)
 * %
 
 * % M.B. 14/10/2003 - LSIIT
 *
  En cas d'impossibilite de calculer le MGI, q et p ne sont pas
  modifi�.
*/

/* Par : Benjamin Maurin, Doctorant LSIIT/EAVR,
                          B150a, ENSPS, Bd Sebastien Brant
                          67400 ILLKIRCH - FRANCE 
                          Tel: (03 902)44461 Fax: (03 902)44480
                          Email: maurin@eavr.u-strasbg.fr
*/

/* NOTE : Les articulations p1,p5, q14 et q15 sont invers�s
         (angle orient�dans l'autre sens) par rapport a l'article
*/

int CTBot_MGI(p3d_matrix4 Ff, double q[13]) {
  double Fx,Fy,Fz;
  double Zx,Zy,Zz,Znorme;
  double p1,C1,S1,p2b,p2,q3,q4,q8,p7,p7b,p9,C8,S8,p5,C5,S5,X14,q14,S14,C14,q15,q15b,p16,C16,S16;
  double p11,p12,p12p,p13;
  double Sigmap2q34,Sigmap79q8,Cp2q34,Sp2q34;
  double B,C,alpha,beta,gamma;
  p3d_matrix4 F13,F14,F15,F16;
  p3d_matrix4 Tm;
  //p3d_vector3 O13;
  //double F13_1_1;

  // Geometric data (should be measured on the model !!!)
  double LBH  = 0.006+0.001;
  double LBT  = 0.0758353-0.002;
  double LPH  = 0.028+0.00;
  double LPT  = 0.065+0.005;
  double a1 = 0.040;
  double a2 = 0.067;
  double a3 = 0.045+0.01;
  double LBX  = 0.069622-0.002;
  double LBY  = 0.040;
  double LBZ  = 0.006+0.057;
  double LPX  = 0.104;
  double LPY  = 0.04;
  double b1 = 0.075;
  double b2 = 0.060;
  double b3 = 0.028;

  // Position du point F
  Fx = Ff[0][3];
  Fy = Ff[1][3];
  Fz = Ff[2][3];
  // Vecteur norm�de descente (2 degres de liberte car ||Z||=1)
  Znorme = sqrt(SQR(Ff[0][2])+SQR(Ff[1][2])+SQR(Ff[2][2]));
  Zx = Ff[0][2]/Znorme;
  Zy = Ff[1][2]/Znorme;
  Zz = Ff[2][2]/Znorme;

  //Patte 1

  //Recherche de p1:
  p1 = atan2(Fx,Fz-LBH);
  C1 = cos(p1);
  S1 = sin(p1);

  // Calcul de la somme Sigma(p2+q3+q4):
  Sigmap2q34 = -atan(Zy/(S1*Zx+C1*Zz));
  Cp2q34 = cos(Sigmap2q34);
  Sp2q34 = sin(Sigmap2q34);

  // Coefficients temporaires: B et C pour trouver q1:
  B = Fy+LBT-Cp2q34*LPT+Sp2q34*LPH;
  C = S1*Fx+C1*Fz-C1*LBH-Sp2q34*LPT-Cp2q34*LPH-a1;
  q3 = -acos(0.5*(B*B+C*C-a2*a2-a3*a3)/(a2*a3));

  // On utilise B et C, d'ou on tire p2:
  //p2a = 2.0*atan((a2+a3*cos(q1)+sqrt(a2*a2+2*a3*a2*cos(q1)+a3*a3-B*B))/(a3*sin(q1)-B));
  // ou:
  p2b = 2.0*atan((a2+a3*cos(q3)-sqrt(a2*a2+2*a3*a2*cos(q3)+a3*a3-B*B))/(a3*sin(q3)-B));
  // On choisit p2b:
  p2 = p2b;

  // Enfin on peut trouver q2 grace a Sigma:
  q4 = Sigmap2q34-p2-q3;

  //%patte 2
  Sigmap79q8 = Sigmap2q34;

  B = Fy-LBT+Cp2q34*LPT+Sp2q34*LPH;
  C = S1*Fx+C1*Fz-C1*LBH+Sp2q34*LPT-Cp2q34*LPH-a1;
  q8 = acos(0.5*(B*B+C*C-a3*a3-a2*a2)/(a3*a2));
  C8 = cos(q8);
  S8 = sin(q8);

  p7b = 2*atan((a2+a3*C8-sqrt(a2*a2+2*a3*a2*C8+a3*a3-B*B))/(a3*S8-B));
  p7 = p7b;
  p9 = Sigmap79q8-p7-q8;

  //%Angle commun au deux pattes
  p5 = atan2(C1*Zx-S1*Zz, (S1*Zx+C1*Zz)/Cp2q34 );
  C5 = cos(p5);
  S5 = sin(p5);

  //%patte 3
  p16 = -atan2(-S1*Sp2q34*(LBX+Fx)-Cp2q34*(-LBY+Fy)-C1*Sp2q34*(-LBZ+Fz)-LPY,
               Zx*(LBX+Fx)+Zy*(-LBY+Fy)+Zz*(-LBZ+Fz));
  C16 = cos(p16);
  S16 = sin(p16);

  alpha = (C1*C5-S1*Cp2q34*S5)*(LBX+Fx)+Sp2q34*S5*(-LBY+Fy)
          +(-S1*C5-C1*Cp2q34*S5)*(-LBZ+Fz)-LPX;
  beta =  S16*(S1*Sp2q34*(LBX+Fx)+Cp2q34*(-LBY+Fy)+C1*Sp2q34*(-LBZ+Fz)+LPY)
          +C16*(Zx*(LBX+Fx)+Zy*(-LBY+Fy)+Zz*(-LBZ+Fz))-b3;
  gamma = alpha*alpha+beta*beta;

  X14 = -0.5*(b2*b2+b1*b1-gamma)/(b2*b1);
  q14 = acos(X14);
  C14 = X14;
  S14 = sin(q14);

  q15b = 2*atan((b1*C14+b2-sqrt(2*b2*b1*C14+b2*b2+b1*b1-alpha*alpha))/(b1*S14-alpha));
  q15  = q15b;

  // -----------------------------------------------------------------------------
  // cardan
  // WARNING : operations are not optimized in this part of the function !!!

  p3d_mat4Pos(Tm,-LPX,LPY,0.0,-p16,0.0,0.0);
  p3d_mat4Mult(Ff,Tm,F16);
  p3d_mat4Pos(Tm,0.0,0.0,-b3,0.0,-q15,0.0);
  p3d_mat4Mult(F16,Tm,F15);
  p3d_mat4Pos(Tm,0.0,0.0,-b2,0.0,-q14,0.0);
  p3d_mat4Mult(F15,Tm,F14);
  p3d_mat4Pos(Tm,0.0,0.0,-b1,0.0,0.43633,0.0);  // 0.43633 = 25 !!!
  p3d_mat4Mult(F14,Tm,F13);

  // FOR CHECKING
  /*   p3d_mat4Print(Ff,"Ff"); */
  /*   p3d_mat4Print(F16,"F16"); */
  /*   p3d_mat4Print(F15,"F15"); */
  /*   p3d_mat4Print(F14,"F14"); */
  /*   p3d_mat4Print(F13,"F13"); */
  // F13 origin position
  /*   O13[0] = -LBX; */
  /*   O13[1] =  LBY; */
  /*   O13[2] =  LBZ; */
  /*   printf("O13 = %f , %f , %f\n",O13[0],O13[1],O13[2]); */

  p11 = atan2(F13[1][0],F13[0][0]);
  p13 = atan2(F13[2][1],F13[2][2]);

  p12p = acos(F13[0][0]/cos(p11));

  if(p12p != -asin(F13[2][0]))
    p12p = -p12p;

  // FOR CHECKING
  //F13_1_1 = cos(p11)*cos(p13) + sin(p11)*sin(p12p)*sin(p13);

  p12 = p12p - 0.43633;  // 0.43633 = 25 !!!

  // -----------------------------------------------------------------------------

  if (isnan(q3)||isnan(q4)||isnan(q8)||isnan(q14)||isnan(q15)||isnan(p1)
      ||isnan(p2)||isnan(p5)||isnan(p7)||isnan(p9)||isnan(p16)
      ||isnan(p11)||isnan(p12)||isnan(p13)) {
    return(0);
  } else {
    /*     q[0]  = q3; */
    /*     q[1]  = q4; */
    /*     q[2]  = q8; */
    /*     q[3]  = q14; */
    /*     q[4]  = q15; */

    /*     q[5]  = p1; */
    /*     q[6]  = p2; */
    /*     q[7]  = p5; */
    /*     q[8]  = p7; */
    /*     q[9]  = p9; */
    /*     q[10] = p16; */

    // NOTE : p5, p10 and p16 are not used !

    q[0]  = p1;
    q[1]  = p2;
    q[2]  = q3;
    q[3]  = q4;
    q[4]  = p1; // p6 = p1
    q[5]  = p7;
    q[6]  = q8;
    q[7]  = p9;
    //q[8]  = 0;//?;
    //q[9]  = 0;//?;
    //q[10] = 0;//?;
    q[8]  = p11;
    q[9]  = p12;
    q[10] = p13;
    q[11] = q14;
    q[12] = q15;

    return(1);
  }
}

/*! \brief Funtion that compute the inverse kinematics
 *  of Justin arm 6 Dof 
 *
 * \param  sjnt: Start joint number
 * \param  ffjnt: Freeflyer joint. We move this joint and the arm should follow
 * \param  arm: left or right arm ?
 *
 * \retval q: The arm config.
 *
 * \note If the constraints doesn't exist then all numbers are set to 0.
 */
int compute_ik_justin_arm (double *q, int sjnt, int ffjnt, int arm) {
  p3d_rob* rob = XYZ_ROBOT;
  p3d_jnt *startJnt = rob->joints[sjnt+5], *effJnt = rob->joints[ffjnt];
  p3d_matrix4 tldofTarget, tmp; //homogenious matrix of the last dof of the arm. It is computed from the current free flyer H. matrix. tldofTarget = (TldofInit^-1 * TffInit)^-1 * TffTarget
  int ta,tb,tc;
  double a=0,b=0,c=0,d=0,e=0,f=0,A11,A12,A13,A14,A21,A22,A23,A24,A31,A32,A33,A34;
  double r2 = arm*400, r4 = arm*390;

  p3d_matInvertXform(startJnt->pos0, tmp);
  p3d_mat4Mult(tmp, effJnt->pos0, tldofTarget);
  p3d_matInvertXform(tldofTarget, tmp);
  p3d_mat4Mult(effJnt->abs_pos, tmp, tldofTarget);

  A11 = tldofTarget[0][0];
  A12 = tldofTarget[0][1];
  A13 = tldofTarget[0][2];
  A14 = tldofTarget[0][3];
  A21 = tldofTarget[1][0];
  A22 = tldofTarget[1][1];
  A23 = tldofTarget[1][2];
  A24 = tldofTarget[1][3];
  A31 = tldofTarget[2][0];
  A32 = tldofTarget[2][1];
  A33 = tldofTarget[2][2];
  A34 = tldofTarget[2][3];

  //1st case, b = PI/2 Or -PI/2;
  
  if (A34 != 0){
    ta = justin_a(&a, A14, A24, r2, r4,sjnt, rob, 0);
    switch(ta){
      case 0:{
        switch(tc = justin_c(&c,a,A14,A24,A34,r2,r4,sjnt+2,rob,0)){
          case 0 :{
            b = PI/2;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }//si on a pas def, on recalcule a.
          }
          default :{
            ta = justin_a(&a, A14, A24, r2, r4,sjnt, rob, 1);
            break;
          }
        }
      }
      case 1:{
        switch(tc = justin_c(&c,a,A14,A24,A34,r2,r4,sjnt+2,rob,1)){
          case 1:{
            b = -PI/2;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }/*else{
              return 0;//si on a pas def,on arrete.
            }*/
          }
          default:{
//             return 0;//on arrete le calcul.
          }
        }
      }
      default:{
//         return 0;//on arrete le calcul
      }
    }
    //3rd case 
    ta = justin_a(&a, A14, A24, r2, r4,sjnt, rob, 0);
    switch(ta){
      case 0:{
        tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,3);
        switch(tb){
          case 3:{
            c = PI/4;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }else{//si on a pas def, on recalcule b.
              tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,4);
            }
          }
          case 4:{
            c = -PI/4;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }//si on a pas def, on recalcule b.
          }
          default:{
            tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,1);
            switch(tb){
              case 1:{
                c = -PI/2;
                if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
                  q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
                  return 1;
                }else{//si on a pas def, on recalcule b.
                  tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,2);
                }
              }
              case 2:{
                c = PI/2;
                if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
                  q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
                  return 1;
                }else{//si on a pas def, on recalcule b.
                  tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,0);
                }
                break;
              }
              default:{
                c = 0;
                if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
                  q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
                  return 1;
                }else{
                  return 0;//impossible de calculer la geometrie inverse
                }
              }
            }
          }
        }
      }
      case 1:{
        tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,3);
        switch(tb){
          case 3:{
            c = PI/4;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }else{//si on a pas def, on recalcule b.
              tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,4);
            }
          }
          case 4:{
            c = -PI/4;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }//si on a pas def, on recalcule b.
          }
          default:{
            tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,1);
            switch(tb){
              case 1:{
                c = -PI/2;
                if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
                  q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
                  return 1;
                }else{//si on a pas def, on recalcule b.
                  tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,2);
                }
              }
              case 2:{
                c = PI/2;
                if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
                  q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
                  return 1;
                }else{//si on a pas def, on recalcule b.
                  tb = justin_b(&b,a,r2,r4,A14,A24,A34,sjnt+1,rob,0);
                }
                break;
              }
              default:{
                c = 0;
                if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
                  q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
                  return 1;
                }else{
                  return 0;//impossible de calculer la geometrie inverse
                }
              }
            }
          }
        }
      }
      default:{
        return 0;
      }
    }
  }else{//A34 == 0
    //2nd case, b = 0
    ta = justin_a(&a, A14, A24, r2, r4,sjnt, rob, 2);
    switch(ta){
      case 2:{
        switch(tc = justin_c(&c,a,A14,A24,A34,r2,r4,sjnt+2,rob,2)){
          case 2 :{
            b = 0;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }//si on a pas def, on recalcule a.
          }
          default :{
            ta = justin_a(&a, A14, A24, r2, r4,sjnt, rob, 3);
            break;
          }
        }
      }
      case 3:{
        switch(tc = justin_c(&c,a,A14,A24,A34,r2,r4,sjnt+2,rob,3)){
          case 3:{
            b = 0;
            if (compute_ik_justin_arm_wrist (tldofTarget,sjnt,r2,r4,a,b,c,&d,&e,&f)){
              q[0] = a;q[1] = b;q[2] = c;q[3] = d;q[4] = e;q[5] = f;
              return 1;
            }else{
              return 0;//si on a pas def,on arrete.
            }
          }
          default:{
            return 0;//on arrete le calcul
          }
        }
      }
      case -1:{
        return 0;//on arrete le calcul
      }
    }
  }
}


static int justin_a(double *aOut, double A14, double A24, double r2, double r4,
             int jntpos, p3d_rob* rob, int flagA){
  double t = 0, vmin = 0, vmax = 0, a = *aOut;

  p3d_jnt_get_dof_bounds(rob->joints[jntpos],0,&vmin,&vmax);

  switch(flagA){
    case 0:{
      a = atan(-A14/A24);
      if ((a > vmin) && (a < vmax)) {
        *aOut = a;
        return flagA;//a est validée rendre FlagA
      }else{
        flagA++;//a n'est pas validée => incrémenter et passer au case suvant.
      }
    }
    case 1:{
      a = a - PI/2;
      if ((a > vmin) && (a < vmax)) {
        *aOut = a;
        return flagA;//a est validée rendre FlagA
      }else{
        return -1;//a n'est pas validée => arreter le calcul de la cinématique inverse.
      }
    }
    case 2:{
      t = SQR(SQR(r4)-SQR(r2))+SQR(SQR(A24)+SQR(A14))-2*(SQR(r4)+SQR(r2))*(SQR(A24)+SQR(A14));
      t = t > 0 ? t : -t;
      a = atan(-(A24*sqrt(t)+A14*(SQR(r2)+SQR(A14)+SQR(A24)-SQR(r4)))/(r2*(SQR(A24)+SQR(A14))));
      if ((a > vmin) && (a < vmax)) {
        *aOut = a;
        return flagA;//a est validée rendre FlagA
      }else{
        flagA++;//a n'est pas validée => incrémenter et passer au case suvant.
      }
    }
    case 3:{
      t = SQR(SQR(r4)-SQR(r2))+SQR(SQR(A24)+SQR(A14))-2*(SQR(r4)+SQR(r2))*(SQR(A24)+SQR(A14));
      t = t > 0 ? t : -t;
      a = atan((-A14*sqrt(t)+A24*(SQR(r2)-SQR(r4)+SQR(A14)+SQR(A24)))/(r2*(SQR(A24)+SQR(A14))));
      if ((a > vmin) && (a < vmax)) {
        *aOut = a;
        return flagA;//a est validée rendre FlagA
      }else{
        return -1;//a n'est pas validée => arreter le calcul de la cinématique inverse.
      }
    }
  }
  return 0;
}

static int justin_b(double *bOut, double a, double r2, double r4, 
             double A14, double A24, double A34, 
             int jntpos, p3d_rob* rob, int flagB){
  double alpha = 0, vmin = 0, vmax = 0, sa = sin(a), ca = cos(a),sb = 0, cb = 0, b = *bOut;

  p3d_jnt_get_dof_bounds(rob->joints[jntpos],0,&vmin,&vmax);

  switch (flagB){
    case 0:{//c = 0
      b = PI/4;
      *bOut = b;
      return flagB;
    }
    case 1:{//c = -PI/2
      b = r4/A34;
      if ((b > vmin) && (b < vmax)) {
        *bOut = b;
        return flagB;//b est validée rendre FlagB
      }else{
        return -1;//b n'est pas validée => arreter le calcul de la cinématique inverse.
      }
    }
    case 2:{//c = PI/2
      b = -r4/A34;
      if ((b > vmin) && (b < vmax)) {
        *bOut = b;
        return flagB;//b est validée rendre FlagB
      }else{
        return -1;//b n'est pas validée => arreter le calcul de la cinématique inverse.
      }
    }
    case 3:{//c=PI/4
      alpha = (A14*ca+A24*sa)/A34;
      sb = -((A14*sa+r2-A24*ca)/(A14*alpha*ca+A24*sa*alpha+A34));
      cb = sb*alpha/A34;
      if (cb != 0){
        b = atan(sb/cb);
        if (cb < 0){
          b = b > 0 ? b + PI/2 : b - PI/2;
        }
        if ((b > vmin) && (b < vmax)) {
          *bOut = b;
          return flagB;//b est validée rendre FlagB
        }else{
          flagB++;
        }
      }
    }
    case 4:{//c=-PI/4
      alpha = (A14*ca+A24*sa)/A34;
      sb = ((A14*sa+r2-A24*ca)/(A14*alpha*ca+A24*sa*alpha+A34));
      cb = sb*alpha/A34;
      if (cb != 0){
        b = atan(sb/cb);
        if (cb < 0){
          b = b > 0 ? b + PI/2 : b - PI/2;
        }
        if ((b > vmin) && (b < vmax)) {
          *bOut = b;
          return flagB;//b est validée rendre FlagB
        }else{
          return -1;//b n'est pas validée => arreter le calcul de la cinématique inverse.
        }
      }
    }
  }
  return 0;
}
static int justin_c(double *cOut, double a,
             double A14, double A24, double A34, double r2, double r4,
             int jntpos, p3d_rob* rob, int flagC){
  double t = 0, alpha = 0, beta = 0, sa = sin(a), ca = cos(a), c = *cOut, vmin, vmax;

  p3d_jnt_get_dof_bounds(rob->joints[jntpos],0,&vmin,&vmax);
  
  switch (flagC){
    case 0:{
      alpha = A14*sa-A24*ca+r2;
      t = SQR(alpha)+SQR(A34)-SQR(r4);
      beta = alpha + A34;
      alpha = alpha - A34;
      if (t >= 0){
        c = atan((beta*r4+alpha*sqrt(t))/(alpha*r4-beta*sqrt(t)));
        if ((c > vmin) && (c < vmax)) {
          *cOut = c;
          return flagC;
        }else{
          flagC++;
        }
      }
    }
    case 1:{
      alpha = A14*sa-A24*ca+r2;
      t = SQR(alpha)+SQR(A34)-SQR(r4);
      beta = alpha + A34;
      alpha = alpha - A34;
      if (t >= 0){
        c = atan((beta*r4-alpha*sqrt(t))/(alpha*r4+beta*sqrt(t)));
        if ((c > vmin) && (c < vmax)) {
          *cOut = c;
          return flagC;
        }else{
          return -1;
        }
      }
      return -1;
    }
    case 2:{
      t = SQR(SQR(r4)-SQR(r2))+SQR(SQR(A24)+SQR(A14))-2*(SQR(r4)+SQR(r2))*(SQR(A24)+SQR(A14));
      t = t > 0 ? t : -t;
      c = atan(sqrt(t)/(r4*r2));
      if ((c > vmin) && (c < vmax)) {
        *cOut = c;
        return flagC;
      }else{
        flagC++;
      }
    }
    case 3:{
      c = atan((SQR(r4)-SQR(A14)+SQR(r2)-SQR(A24))/(r2*r4));
      if ((c > vmin) && (c < vmax)) {
        *cOut = c;
        return flagC;
      }else{
        return -1;
      }
    }
  }
  return 0;
}

static int compute_ik_justin_arm_wrist (p3d_matrix4 tldofTarget, int sjnt, int r2, int r4,
                                 double a, double b, double c,
                                 double *dOut, double *eOut, double *fOut) {
  p3d_rob* rob = XYZ_ROBOT;
  int eOk;
  double A11,A12,A13,A14,A21,A22,A23,A24,A31,A32,A33,A34,alpha,beta,gamma,delta,zeta,eta,se,ce,sd,cd,sf,cf,vmin,vmax;
  double sa = sin(a), ca = cos(a), sb = sin(b), cb = cos(b), sc = sin(c), cc = cos(c);
  double d = 0, e = 0, f = 0;
  A11 = tldofTarget[0][0];
  A12 = tldofTarget[0][1];
  A13 = tldofTarget[0][2];
  A14 = tldofTarget[0][3];
  A21 = tldofTarget[1][0];
  A22 = tldofTarget[1][1];
  A23 = tldofTarget[1][2];
  A24 = tldofTarget[1][3];
  A31 = tldofTarget[2][0];
  A32 = tldofTarget[2][1];
  A33 = tldofTarget[2][2];
  A34 = tldofTarget[2][3];

  delta = -A13*sc*cb*ca+A11*sa*cc-A23*sc*sa*cb-A23*ca*cc-A33*sb*sc;
  beta = A13*sa*sc-A23*ca*sc+A13*cc*cb*ca+A23*sa*cc*cb+A33*sb*cc;
  eta = sb*A13*ca+sa*sb*A23+cb*A33;
  alpha = sb*A31*cc+A21*sa*cc*cb+A11*cc*cb*ca+A11*sa*sc-ca*A21*sc;
  zeta = sb*A11*ca+sa*sb*A21-cb*A31;
  gamma = -A11*sc*cb*ca+A11*sa*cc-A21*sc*sa*cb-A21*ca*cc-sb*sc*A31;

  if (delta < LOCAL_COMPUTATION_EPSILON && delta > -LOCAL_COMPUTATION_EPSILON){//hors bornes.
    return 0; //impossible de calculer d e f
  }
  if(SQR(eta)+SQR(beta) < LOCAL_COMPUTATION_EPSILON &&
     SQR(eta)+SQR(beta) > LOCAL_COMPUTATION_EPSILON){
    if (delta < -1+LOCAL_COMPUTATION_EPSILON && delta > -1-LOCAL_COMPUTATION_EPSILON  && 
        gamma < LOCAL_COMPUTATION_EPSILON && gamma > -LOCAL_COMPUTATION_EPSILON){
      e = 0;
    }else{
      return 0; //impossible de calculer d e f
    }
    //e = 0;sin(d-f)=zeta;cos(d-f) = alpha
    if (alpha < LOCAL_COMPUTATION_EPSILON && alpha > -LOCAL_COMPUTATION_EPSILON){
      if (zeta < 1+LOCAL_COMPUTATION_EPSILON && zeta > 1-LOCAL_COMPUTATION_EPSILON){//d-f = PI/2
        f = 0;
        d = PI/2;
        *dOut = d;
        *eOut = e;
        *fOut = f;
        return 1;
      }else if(zeta < -1+LOCAL_COMPUTATION_EPSILON && zeta > -1-LOCAL_COMPUTATION_EPSILON){//d-f = -PI/2
        f = 0;
        d = -PI/2;
        *dOut = d;
        *eOut = e;
        *fOut = f;
        return 1;
      }else{
        return 0; //impossible de calculer d e f
      }
    }else{
      f = 0;
      d = atan(zeta/alpha);
      *dOut = d;
      *eOut = e;
      *fOut = f;
      return 1;
    }
  }else{//sin(e) != 0
    //case 1 : sin(e) = + sqrt(SQR(eta)+SQR(beta));
    e = atan(sqrt(SQR(eta)+SQR(beta))/delta);
    p3d_jnt_get_dof_bounds(rob->joints[sjnt+4],0,&vmin,&vmax);
    if ((e > vmin) && (e < vmax)) {
      eOk = 1;
    }else{
      e = e > 0 ? e - PI : e + PI;
      if ((e > vmin) && (e < vmax)) {
        eOk = 1;
      }else{
        eOk = 0;
      }
    }
    //case 2 : sin(e) = - sqrt(SQR(eta)+SQR(beta));
    if (eOk == 0){
      e = atan(-sqrt(SQR(eta)+SQR(beta))/delta);
      p3d_jnt_get_dof_bounds(rob->joints[sjnt+4],0,&vmin,&vmax);
      if ((e > vmin) && (e < vmax)) {
        eOk = 1;
      }else{
        e = e > 0 ? e - PI : e + PI;
        if ((e > vmin) && (e < vmax)) {
          eOk = 1;
        }else{
          return 0;
        }
      }
    }
    se = sin(e);
    ce = sin(e);
    sd = -eta/se;
    cd = beta/se;
    if (beta < LOCAL_COMPUTATION_EPSILON && beta > -LOCAL_COMPUTATION_EPSILON){//cd = 0 => d = -Pi/2 ou d = Pi/2
      if (sd < 1+LOCAL_COMPUTATION_EPSILON && sd > 1-LOCAL_COMPUTATION_EPSILON){
        d = PI/2;
      }else if(sd < -1+LOCAL_COMPUTATION_EPSILON && sd > -1-LOCAL_COMPUTATION_EPSILON){
        d = -PI/2;
      }else{
        return 0;
      }
    }else{//beta != 0;
      d = atan(sd/cd);
      if (cd < 0){
        d = d > 0 ? d - PI : d + PI;
      }
    }
    cf = gamma/se;
    if (cd > LOCAL_COMPUTATION_EPSILON && cd < -LOCAL_COMPUTATION_EPSILON){
      sf = (zeta + sd*ce*cf)/cd;
    }else{
      sf = (alpha + cd*ce*cf)/sd;
    }
    if (cf < LOCAL_COMPUTATION_EPSILON && cf > -LOCAL_COMPUTATION_EPSILON){
      if (sf < 1+LOCAL_COMPUTATION_EPSILON && sf > 1-LOCAL_COMPUTATION_EPSILON){
        f = PI/2;
      }else if(sf < -1+LOCAL_COMPUTATION_EPSILON && sf > -1-LOCAL_COMPUTATION_EPSILON){
        f = -PI/2;
      }else{
        return 0;
      }
    }else{
      f = atan(sf/cf);
      if (cf < 0){
        f = f > 0 ? f - PI : f + PI;
      }
    }
    *dOut = d;
    *eOut = e;
    *fOut = f;
    return 1;
  }
}
