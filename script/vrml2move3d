#!/usr/bin/perl

#---------------------------------------------------------------
#  Traducteur VRML 2.0 -> MOVE3D
#--------------------------------------------------------------

$noDebug = 1;
$keeplink = 0;

   ##################
 ###                ###
##   FICHIERS DEBUG   ##
 ###                ###
   ##################

$noDebug or open(BUG, ">".'debug') or die "\nCannot open debug file\n";
$noDebug or open(READ, ">".'debugRead') or die "\nCannot open debugRead file\n";

$NoFirstRead = 1;
$NoFirstRead2 = 1;
$NoFirstReadProto = 1;
$NoFirstStep = 1;
$NoShapeHierarchy = 1;
$NoConsole = 1;
$NoConsoleHeader = 1;
$NoTracking = 1;

$NoPercent = 0;

$afficheNoColor = 1;
$afficheNone = 1;
$NoErr = 1;
$NoGlobal = 1;
$NoXtreme = 1;
$NoVprod = 1;
$NoNormal = 1;
$NoGlobal = 1;
$NoXtreme = 1;
$NoVprod = 1;

$Global = $NoGlobal-1;
$afficheRes = 0;
$afficheVProd = $NoVProd-1;
$afficheMat = 1;
$afficheTrans = 1;

$DoNotGlobalTranslate = 0;

sub printbug {
  local($state,$tab_name,@table)=@_;
  if($state) {
    print BUG "\n"; 
    print BUG "$tab_name\tdim = $#table\n";
    $quat = 4;
    for($line=0;$line<=$#table;$line++) {
      if($line == $quat) {
	print BUG "\n";
	$quat += 4;
      }
      for($column=0;$column<4;$column++) {
	print BUG "$table[$line][$column]\t";
      }
      print BUG "\n\n";
    }
  }
}

sub printbug2 {
  local($state,$tab_name,@table)=@_;
  if($state) {
    print BUG "\n"; 
    print BUG "$tab_name\tdim = $#table\n";
    $quat = 4;
    for($line=0;$line<=$#table;$line++) {
      if($line == $quat) {
	print BUG "\n";
	$quat += 4;
      }
      print BUG "$table[$line]\t";
    }
    print BUG "\n\n";
  }
}


   #################
 ###               ###
##    DEFINITIONS    ##
 ###               ###
   #################

$clean_die = 1;
sub mydie {
  local(@die) = @_;
  close(OUTPUT);
  close(INPUT);
  close(MACRO);
  close(MACROTMP);
  close(COPY);
  close(COPYR);
  close(COPYW);
  close(USETEMP);
  close(READ);
  close(FINAL);
  close(TEMP);
  if($clean_die) {
    unlink(<*.*>);
    chdir("..");
    rmdir("MACROS");
    unlink(<*.*>);
    chdir("..");
    rmdir($env_name);
  }
  die "@die";
}

##
##  Expressions regulieres
##

$number = '[-+]?\.?\d+\.?\d*[eE]?[-+]?\d*';
$name = '[\w\.\_\-\+\%]+';
$move3d_file = '[\w\_\-]+\.[pP]3[dD]';
$vrml_file = '[\w\_\-]+\.[wW][rR][lLzZ]';
$open_bracket = '\{';
$close_bracket = '\}';
$open_children = '\[';
$close_children = '\]';
$file_type = '[ro]';
$border = '\\b(?![-+%\$\"\.])';

##
##  Constantes
##

$beg_time = time;
$max = 1E32;
$epsilon = 1E-06;
$PI = 3.14159265358979;
$PI2 = $PI/2;
$R2D = 180/$PI;
@id4 = ([1.0,0.0,0.0,0.0],[0.0,1.0,0.0,0.0],[0.0,0.0,1.0,0.0],[0.0,0.0,0.0,1.0]);

$children_extended = "\\bchildren$border|\\bhumanoidBody$border";
$transform_extended = "\\bTransform$border|\\bHumanoid$border|\\bJoint$border";
$group_extended = "\\bGroup$border|\\bSegment$border";
$virtual_transform = "Interpolator$border|\\bWorldInfo$border|\\bTextureTransform$border|\\bVisibilitySensor$border|\\bProximitySensor$border|\\bLOD$border";

$known_USE_node_call = "\\bappearance$border|\\bmaterial$border|\\bgeometry$border|\\bcoord$border|\\bchildren$border";
$section_used = "\\bllimit$border|\\bulimit$border|\\bpoint$border|\\bcoordIndex$border|\\bchildren$border|\\bhumanoidBody$border";
$left_separate = "\\bllimit$border|\\bulimit$border|\\bgeometry$border|\\bpoint$border|\\bcoord$border|\\bcoordIndex$border|\\bheight$border|\\bradius$border|\\bbottomRadius$border|\\bsize$border|\\bmaterial$border|\\bappearance$border|\\bdiffuseColor$border|\\bccw$border|\\bsolid$border|\\btranslation$border|\\brotation$border|\\bscale$border|\\bscaleOrientation$border|\\bcenter$border|\\bname$border";
$right_separate = "\\bFALSE$border";
$both_separate = "\\[|\\]|\\bchildren$border|\\bhumanoidBody$border";
$none_separate = "Interpolator$border|\\bWorldInfo$border|\\burl$border|\\bInline$border|\\bTextureTransform$border|\\bVisibilitySensor$border|\\bProximitySensor$border|\\bLOD$border|\\bPROTO$border|\\bAnchor$border|\\bBillboard$border|\\bCollision$border|\\bSwitch$border|\\bShape$border|\\bBox$border|\\bCylinder$border|\\bCone$border|\\bSphere$border|\\bIndexedFaceet$border|\\bTransform$border|\\bHumanoid$border|\\bJoint$border|\\bGroup$border|\\bSegment$border";


##
##  Variables
##

$one_file_obstacle = 0;
$h_anim = -3;
$no_spherical = 0;

$externfiles = 0;
$url = 0;
$proto = 0;
$lod = 0;

$total_lines = 0;
$percent = 0;
$compteur = 0;
$faces = 0;
$macro_nb = 0;
@empty_macro_names = ();
$empty_macro = 1;

$shape_name = "";
$nb_robot = 1;
$nb_obstacle = 1;
$nb_body = 0;
$nb_jnt = 0;

$is_first = 1;
$humanoid_definition = 0;
$add_jnt = 0;
$add_pipo = 0;
$jnt_hierarchy = 1;
@body_hierarchy = ();
@body_names = ();
@body_nb_poly = ();
@jnt_po = (0,0,0);
@jnt_rot = (0,0,1,0);
@jnts_hierarchy = ();
@robot_global_translation = ();
$robot_name = "";
@next_jnt_sphere = ();

@jnt_llimit = ();
@jnt_ulimit = ();

@virtual_transforms_lines = ();

$nb_box = 1; 
$nb_cylinder = 1;
$nb_cone = 1;
$nb_sphere = 1;
$nb_indexedFaceSet = 1;
$box_name = ""; 
$cylinder_name = "";
$cone_name = "";
$sphere_name = "";
$indexedFaceSet_name = "";
$hierarchy = 0;
@hierarchy_inversions = ();
$last_name = "";

$no_exception = 1;
$exception = 0;
$reverse_faces = -1;

@previous_names = ();

@no_use_close_children = ();

@transforms = ();

@colorsRGB = ();
@coord = ();
@coordIndex = ();
@new_pos_res = ();
@xtreme_coord = ();
@xtreme_index = ();
@bounding_boxes = ();

@center = ();
@center_inv = ();
@rotation = ();
@scale = ();
@scaleOrientation = ();
@scaleOrientation_inv = ();
@translation = ();



   #####################
 ###                   ###
##    TRANSFORMATIONS    ##
 ###                   ###
   #####################


#Initialiser les transformations
sub init_transform {
  @center = @id4;
  @center_inv = @id4;
  @rotation = @id4;
  @scale = @id4;
  @scaleOrientation = @id4;
  @scaleOrientation_inv = @id4; 
  @translation = @id4;
}

#Construire la matrice de translation "center"
sub build_center {
  @center     = ([1.0,0.0,0.0, $_[0]],[0.0,1.0,0.0, $_[1]],[0.0,0.0,1.0, $_[2]],[0.0,0.0,0.0,1.0]);
  @center_inv = ([1.0,0.0,0.0,-$_[0]],[0.0,1.0,0.0,-$_[1]],[0.0,0.0,1.0,-$_[2]],[0.0,0.0,0.0,1.0]);
  &printbug($afficheMat,"CENTER",@center);
  &printbug($afficheMat,"CENTER_INV",@center_inv);
}


#Construire la matrice de translation "translation"
sub build_translation {
  @translation = ([1.0,0.0,0.0,$_[0]],[0.0,1.0,0.0,$_[1]],[0.0,0.0,1.0,,$_[2]],[0.0,0.0,0.0,1.0]);
  &printbug($afficheMat,"TRANSLATION",@translation);
}

#Construire la matrice d'homotethie "scale"
sub build_scale {
  @scale = ([$_[0],0.0,0.0,0.0],[0.0,$_[1],0.0,0.0],[0.0,0.0,$_[2],0.0],[0.0,0.0,0.0,1.0]);
  &printbug($afficheMat,"SCALE",@scale);
}

#Construire la matrice de rotation autour d'un axe quelconque
sub rand_axe {
  $n2 = $_[0]*$_[0]+$_[1]*$_[1]+$_[2]*$_[2];
  $n  = sqrt($n2);
  $d = 1;
  if($n) { $d = $n; }
  $x  = $_[0]/$d;
  $y  = $_[1]/$d;
  $z  = $_[2]/$d;
  $s  = sin($_[3]);
  $c  = cos($_[3]);
  $v  = 1-$c;
  ([$x*$x*$v+$c,$x*$y*$v-$z*$s,$x*$z*$v+$y*$s,0.0],[$x*$y*$v+$z*$s,$y*$y*$v+$c,$y*$z*$v-$x*$s,0.0],[$x*$z*$v-$y*$s,$y*$z*$v+$x*$s,$z*$z*$v+$c,0.0],[0.0,0.0,0.0,1.0]);
}

#Construire la matrice de rotation "rotation"
sub build_rotation {
  @rotation = &rand_axe($_[0],$_[1],$_[2],$_[3]);
  &printbug($afficheMat,"ROTATION",@rotation);
}

#Construire la matrice de rotation "scaleOrientation"
sub build_scaleOrientation {
  @scaleOrientation     = &rand_axe($_[0],$_[1],$_[2], $_[3]);
  @scaleOrientation_inv = &rand_axe($_[0],$_[1],$_[2],-$_[3]);
  &printbug($afficheMat,"SCALE_ORIENTATION",@scaleOrientation);
  &printbug($afficheMat,"SCALE_ORIENTATION_INV",@scaleOrientation_inv);
}


#Produit matriciel 4*4 # 4*4 -> 4*4
sub mprod {
  local(@twice_matrix) = ();
  local(@result) = ();
  for($l=0;$l<=$#_;$l++) {
    for($c=0;$c<4;$c++) {
      $twice_matrix[$l][$c] = $_[$l][$c];
    }
  }
  &printbug($afficheRes,"TWICE MATRIX",@twice_matrix);

  for($i=0;$i<4;$i++) {
    for($j=0;$j<4;$j++) {
      $res = 0;
      for($k=0;$k<4;$k++) {
        $res += $twice_matrix[$i][$k] * $twice_matrix[$k+4][$j];
      }
      $result[$i][$j] = $res;
    }
  }

  &printbug($afficheRes,"RESULT",@result);

  #&printbug($afficheTrans,"TRANSFORMS de mprod",@transforms);
 
  @result;
}


#Produit matriciel 4*4 # (2 4*1) -> (2 4*1)
sub vprod {
  local(@matrix_max_min) = ();
  local(@vmax) = ();
  local(@vmin) = ();
  for($l=0;$l<=$#_;$l++) {
    for($c=0;$c<4;$c++) {
      $matrix_max_min[$l][$c] = $_[$l][$c];
    }
  }
  
  &printbug($afficheVProd,"MATRIX_MAX_MIN",@matrix_max_min);

  for($i=0;$i<4;$i++) {
    $res_min = 0;
    $res_max = 0;
    for($k=0;$k<4;$k++) {
      $res_max += $matrix_max_min[$i][$k] * $matrix_max_min[4][$k];
      $res_min += $matrix_max_min[$i][$k] * $matrix_max_min[5][$k];
    }
    $vmax[$i] = $res_max;
    $vmin[$i] = $res_min;
  }

  &printbug($afficheVProd,"MAX_MIN",([@vmax],[@vmin]));
  ([@vmax],[@vmin]);
}


#Construire la matrice de transformations
sub build_transforms_mat {
#DEBUG
$afficheNone or print BUG "Build-Transform...\n";

  &printbug($afficheTrans,"##CENTER_INV",@center_inv);
  &printbug($afficheTrans,"##SCALE_ORIENTATION_INV",@scaleOrientation_inv);
  &printbug($afficheTrans,"##SCALE",@scale);
  &printbug($afficheTrans,"##SCALE_ORIENTATION",@scaleOrientation);
  &printbug($afficheTrans,"##ROTATION",@rotation);
  &printbug($afficheTrans,"##CENTER",@center);
  &printbug($afficheTrans,"##TRANSLATION",@translation);

$afficheNone or print BUG "Build-Transform fini\n";

  local(@transmat) = mprod(@translation,mprod(@center,mprod(@rotation,mprod(@scaleOrientation,mprod(@scale,mprod(@scaleOrientation_inv,@center_inv))))));
$afficheNone or print  BUG "transforms is to be pushed with:\n";
  &printbug($afficheTrans,"RESULTAT: transmat",@transmat);

  @transmat;
}




   ################
 ###              ###
##    TRADUCTION    ##
 ###              ###
   ################

##
##  MATERIAL
##
sub material_sub {
  #ligne du "material"  
  $stop_material = 0;
  local(@initial_color) = (0.8,0.8,0.8);

  do {
    if(/^\s*\#/ || /^\s*$/) {
     COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/\bdiffuseColor$border\s+($number)\s+($number)\s+($number)/) {
      #ligne du "diffuseColor R G B"
      @initial_color = ($1,$2,$3);
#DEBUG
$afficheNoColor or print BUG "diffuseColor $1 $2 $3\t$inputnb\n";
    }

    if(/$close_bracket/) { 
#DEBUG
$afficheNoColor or print BUG "material:\t$1 $inputnb\n";
      $stop_material = 1;
      #ligne du "}" du 'material'
      splice(@colorsRGB,$#colorsRGB-2,3);
      push(@colorsRGB,($initial_color[0],$initial_color[1],$initial_color[2]));  #ANY COLOR
#ICI
#$test = @colorsRGB/3;
#print BUG "($test)[$inputnb][$indexedFaceSet_name] $colorsRGB[$#colorsRGB-2] $colorsRGB[$#colorsRGB-1] $colorsRGB[$#colorsRGB]\n";
    }
    unless($stop_material){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "MATERIAL: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_material);
  $_;
}

##
##  JOINT [UL]LIMIT
##
sub jntlimit_sub {
  local($type) = (/u/) ? "u" : "l";
  local($stop_limit) = 0;

  do {
    if(/^\s*\#/ || /^\s*$/) {
     COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/($number)\s+($number)\s+($number)/) {
      if($type eq "l") { 
	splice(@jnt_llimit,$#jnt_llimit-2,3);
	push(@jnt_llimit,(int(10*$3*$R2D)/10,int(10*$1*$R2D)/10,int(10*$2*$R2D)/10));
      }
      if($type eq "u") { 
	splice(@jnt_ulimit,$#jnt_ulimit-2,3);
	push(@jnt_ulimit,(int(10*$3*$R2D)/10,int(10*$1*$R2D)/10,int(10*$2*$R2D)/10));
      }
    }

    if(/\]/) { 
      $stop_limit = 1;
    }

    unless($stop_limit){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "MATERIAL: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_limit);
  $_;
}


##
##  TRANSFORM
##
sub transform_sub {
  #ligne du "transform"  
  local($is_joint) = $_[0];
  local($epfl) = 1;

  &init_transform;
  if($is_joint) { 
    push(@jnt_llimit,(-180.0,-180.0,-180.0));
    push(@jnt_ulimit,(180.0,180.0,180.0));
  }

  $stop_transform = 0;
  push(@hierarchy_inversions,1);

#DEBUG
$NoNormal or print BUG "\nhierarchy_inversions(push 1) = @hierarchy_inversions\t$inputnb\n\n";
  
  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if($is_joint && /\b([lu])limit$border/) {
      $_ = &jntlimit_sub($1);
    }

    if(/^\s*\bcenter$border\s+($number)\s+($number)\s+($number)/) { 
      &build_center($1,$2,$3);
      if($is_joint) {
	$epfl = 0;
	@jnt_po = ($1,$2,$3);
      }
#DEBUG
$afficheNone or print BUG "center $inputnb\t($1,$2,$3)\n";
    }
    if(/^\s*\brotation$border\s+($number)\s+($number)\s+($number)\s+($number)/) { 
      &build_rotation($1,$2,$3,$4);
      if($is_joint) {
	@jnt_rot = ($1,$2,$3,$4);
      }
#DEBUG
$afficheNone or print BUG "rotation $inputnb\t($1,$2,$3,$4)\n";
    }
    if(/^\s*\bscale$border\s+($number)\s+($number)\s+($number)/) { 
      &build_scale($1,$2,$3);
      $hierarchy_inversions[$#hierarchy_inversions] = $1*$2*$3;
#DEBUG
$NoNormal or print BUG "\nhierarchy_inversions(change) = @hierarchy_inversions\t$inputnb\n\n";
#DEBUG
$afficheNone or print BUG "scale $inputnb\t($1,$2,$3)\n";
    }
    if(/^\s*\bscaleOrientation$border\s+($number)\s+($number)\s+($number)\s+($number)/) { 
      &build_scaleOrientation($1,$2,$3,$4);
#DEBUG
$afficheNone or print BUG "scaleOrientation $inputnb\t($1,$2,$3,$4)\n";
    }
    if(/^\s*\btranslation$border\s+($number)\s+($number)\s+($number)/) { 
      &build_translation($1,$2,$3);
      if($is_joint && $epfl) {
	@jnt_po = ($1,$2,$3);
      }
#DEBUG
$afficheNone or print BUG "translation $inputnb\t($1,$2,$3)\n";
    }

    if(/$close_bracket/) {
      pop(@hierarchy_inversions);
      #noeud inutile
      $stop_transform = 1;
    }
    if(/$children_extended/) { 
      $hierarchy++;
$NoShapeHierarchy or print "$last_name  $hierarchy (++)($inputnb)\n";
#DEBUG
$afficheNone or print BUG "children hierarchy++ = $hierarchy\t$inputnb\n";
$afficheNone or print  BUG "\n\nPUSH...\n";

      local(@new_transform) = &build_transforms_mat;

      &printbug($afficheTrans,"NEW_TRANSFORM",@new_transform);
      &printbug($afficheTrans,"TRANSFORMS (apres build_transforms_mat & avant push)",@transforms);
      
      local(@transforms_temp) = (@transforms,@new_transform);
      for($l=0;$l<=$#transforms_temp;$l++) {
	for($c=0;$c<4;$c++) {
	  $transforms[$l][$c] = $transforms_temp[$l][$c];
	}
      }
      &printbug($afficheTrans,"TRANSFORMS (apres push)",@transforms);
      &printbug($afficheMem,"MEM (apres push)",@_);

      #ligne du "children"
      $stop_transform = 1;  
#DEBUG
$afficheNone or print BUG "stop_transform = $stop_transform\n";
$afficheNone or print BUG "children de transform\t$inputnb\n";
    }
    unless($stop_transform){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "TRANSFORM: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_transform);
  $_;
}


##
##  SHAPE
##
sub shape_sub {
  #ligne du "shape"  
  $no_use_shape = 0;
  $stop_shape= 0;
  push(@colorsRGB,(0.8,0.8,0.8));
  $no_geometry = 1;
  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/$open_bracket/) {
      #cas:Appearance|Material|ImageTexture|PixelTexture|MovieTexture|TextureTransform 
      $no_use_shape++;
$NoShapeHierarchy or print "SHAPE $no_use_shape (++)($inputnb)\n";
#DEBUG
$afficheNone or print BUG "no_use_shape++ = $no_use_shape\t$inputnb\n";
    }
    if(/\bMaterial$border\s*($open_bracket)?/) {
      #ligne du "Material"
      unless($1) {
	$no_use_shape++;
$NoShapeHierarchy or print "SHAPE $no_use_shape (++)($inputnb)\n";
#DEBUG
$afficheNone or print BUG "(Material NON FAIT) no_use_shape++ = $no_use_shape\t$inputnb\n";
      }
      $_ = &material_sub;
    }

    if(/\bgeometry$border/) {
#DEBUG
$afficheNone or print BUG "geometry $inputnb\n";
    	#ligne du "geometry"
        $no_geometry = 0;
    	$_ = &geometry_sub;
    }
    if(/$close_bracket/) { 
#DEBUG
$afficheNone or print BUG "shape:\t$1 $inputnb\n";
      $no_use_shape--; 
$NoShapeHierarchy or print "SHAPE $no_use_shape (--)($inputnb)\n";
      unless($no_use_shape){
        $stop_shape = 1;
        #ligne du "}" du 'shape'
        if($no_geometry) {
	  splice(@colorsRGB,$#colorsRGB-2,3);
	}
      }
#DEBUG
$afficheNone or print BUG "stop_shape = $stop_shape\n";
if($stop_shape){$afficheNone or print BUG "no_use_shape-- = 0 = $no_use_shape\tshape_sub fini\t$inputnb\n";}else{$afficheNone or print BUG "no_use_shape-- = $no_use_shape\t$inputnb\n";}
    }
    unless($stop_shape){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "SHAPE (no_use_shape = $no_use_shape): ";
$afficheNone or print BUG "SHAPE (no_use_shape = $no_use_shape)\t$inputnb\n";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_shape);
  $_;
}


##
##  GEOMETRY
##
sub geometry_sub {
  #ligne du "geometry"
  $no_use_geometry = 0;
  $stop_geometry = 0;
 
  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/$open_bracket/) {
      #cas du Text|PointSet|IndexedLineSet|ElevationGrid|Extrusion
      $no_use_geometry++;
#DEBUG
$afficheNone or print BUG "no_use_geometry++ = $no_use_geometry\t$inputnb\n";
    }
    if(/\s*(DEF)?\s*($name)?\s*\bBox$border/) {
#DEBUG
$afficheNone or print BUG "box $inputnb\n";
      #ligne du "Box"
      $empty_macro = 0;
      if($1) {
	$box_name = $2."_box".(++$box_nb);
      } 
      elsif ($#previous_names >= 0) {
	$box_name = $previous_names[$#previous_names]."_box".(++$box_nb);
      }
      else {
	$box_name = "box".(++$box_nb);
      }

      $_ = &box_sub;
      $faces += 6;
    }
    if(/\s*(DEF)?\s*($name)?\s*\bSphere$border/) {
#DEBUG
$afficheNone or print BUG "sphere $inputnb\n";
      #ligne du "Sphere"
      $empty_macro = 0;
      if($1) {
	$sphere_name = $2."_sphere".(++$sphere_nb);
      } 
      elsif ($#previous_names >= 0) {
	$sphere_name = $previous_names[$#previous_names]."_sphere".(++$sphere_nb);
      }
      else {
	$sphere_name = "sphere".(++$sphere_nb);
      }	

      $_ = &sphere_sub;
      $faces += 209;
    }
    if(/\s*(DEF)?\s*($name)?\s*\bCylinder$border/) {
#DEBUG
$afficheNone or print BUG "cylindre $inputnb\n";
      #ligne du "Cylinder"
      $empty_macro = 0;
      if($1) {
	$cylinder_name = $2."_cylindre".(++$cylinder_nb);
      } 
      elsif ($#previous_names >= 0) {
	$cylinder_name = $previous_names[$#previous_names]."_cylindre".(++$cylinder_nb);
      }
      else {
	$cylinder_name = "cylindre".(++$cylinder_nb);
      }

      $_ = &cylinder_sub;
      $faces += 17;
    }
    if(/\s*(DEF)?\s*($name)?\s*\bCone$border/) { 
#DEBUG
$afficheNone or print BUG "cone $inputnb\n";
      #ligne du "Cone"
      $empty_macro = 0;
      if($1) {
	$cone_name = $2."_cone".(++$cone_nb);
      } 
      elsif ($#previous_names >= 0) {
	$cone_name = $previous_names[$#previous_names]."_cone".(++$cone_nb);
      }
      else {
	$cone_name = "cone".(++$cone_nb);
      }

      $_ = &cone_sub;
      $faces += 13;
    }
    if(/\s*(DEF)?\s*($name)?\s*\bIndexedFaceSet$border/) {
#DEBUG
$afficheNone or print BUG "indexedFaceSet $inputnb\n";
      #ligne du "IndexedFaceSet"
      if($1) {
	$indexedFaceSet_name = $2."_polyhedre".(++$indexedFaceSet_nb);
      } 
      elsif ($#previous_names >= 0) {
	$indexedFaceSet_name = $previous_names[$#previous_names]."_polyhedre".(++$indexedFaceSet_nb);
      }
      else {
	$indexedFaceSet_name = "polyhedre".(++$indexedFaceSet_nb);
      }

      $_ = &indexedFaceSet_sub;
    }

    if(/$close_bracket/) { 
#DEBUG
$afficheNone or print BUG "geometry:\t$1 $inputnb\n";
      $no_use_geometry--;
      unless($no_use_geometry) {
        $stop_geometry = 1;
        #ligne du "}" du 'geometry'
      }
#DEBUG
$afficheNone or print BUG "geometry:\tstop_geometry = $stop_geometry\n";
if($stop_geometry){$afficheNone or print BUG "no_use_geometry = 0 = $no_use_geometry\tgeometry_sub fini\t$inputnb\n";}else{$afficheNone or print BUG "no_use_geometry-- = $no_use_geometry\t$inputnb\n";}
    }
    unless($stop_geometry){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "GEOMETRY: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_geometry);
  $_;
}


##
##  SET_PRIM_POS_BY_MAT
##
sub by_mat_sub {
$NoVProd or print BUG "# $_[0] # $_[1] #\n";
  local(@new_pos)=@id4;
  local(@level_transform)=@id4;
  if(($_[0] ne "joint") && ($_[1] == 1)) { 
    @new_pos_res = &rand_axe(1,0,0,-$PI2);
  } else {
    @new_pos_res = @id4;
  }

  local(@new_max_min_res)=();
  local(@new_max_min)=();
  local(@origin_goal_res)=();
  local(@origin_goal)=();

  if($_[0] eq "joint") {
    $origin_goal_res[0][0] = $jnt_po[0];
    $origin_goal_res[0][1] = $jnt_po[1];
    $origin_goal_res[0][2] = $jnt_po[2];
    $origin_goal_res[0][3] = 1;
    $origin_goal_res[1][0] = $jnt_po[0]+$jnt_rot[0];
    $origin_goal_res[1][1] = $jnt_po[1]+$jnt_rot[1];
    $origin_goal_res[1][2] = $jnt_po[2]+$jnt_rot[2];
    $origin_goal_res[1][3] = 1;
  }
  elsif($_[0] eq "box") {
$NoVProd or print BUG "cas box";
    $new_max_min_res[0][0] = $size[0]/2;
    $new_max_min_res[0][1] = $size[1]/2;
    $new_max_min_res[0][2] = $size[2]/2;
    $new_max_min_res[0][3] = 1;
    $new_max_min_res[1][0] = -$size[0]/2;
    $new_max_min_res[1][1] = -$size[1]/2;
    $new_max_min_res[1][2] = -$size[2]/2;
    $new_max_min_res[1][3] = 1;
  } 
  elsif($_[0] eq "sphere") {
$NoVProd or print BUG "cas sphere";
    $new_max_min_res[0][0] = $radius;
    $new_max_min_res[0][1] = $radius;
    $new_max_min_res[0][2] = $radius;
    $new_max_min_res[0][3] = 1;
    $new_max_min_res[1][0] = -$radius;
    $new_max_min_res[1][1] = -$radius;
    $new_max_min_res[1][2] = -$radius;
    $new_max_min_res[1][3] = 1;
  }
  elsif($_[0] eq "cylinder") {
$NoVProd or print BUG "cas cylinder";
    $new_max_min_res[0][0] = $radius;
    $new_max_min_res[0][1] = $height/2;
    $new_max_min_res[0][2] = $radius;
    $new_max_min_res[0][3] = 1;
    $new_max_min_res[1][0] = -$radius;
    $new_max_min_res[1][1] = -$height/2;
    $new_max_min_res[1][2] = -$radius;
    $new_max_min_res[1][3] = 1;
  }
  elsif($_[0] eq "cone") {
$NoVProd or print BUG "cas cone";
    $new_max_min_res[0][0] = $bottomRadius;
    $new_max_min_res[0][1] = $height/2;
    $new_max_min_res[0][2] = $bottomRadius;
    $new_max_min_res[0][3] = 1;
    $new_max_min_res[1][0] = -$bottomRadius;
    $new_max_min_res[1][1] = -$height/2;
    $new_max_min_res[1][2] = -$bottomRadius;
    $new_max_min_res[1][3] = 1;
  }
  elsif($_[0] eq "IFS") {
$NoVProd or print BUG "cas IFS: xtreme_coord = @xtreme_coord";
    for($v=0;$v<3;$v++) {
      $new_max_min_res[0][$v] = $xtreme_coord[$v];
      $new_max_min_res[1][$v] = $xtreme_coord[$v+3];
    }
    $new_max_min_res[0][3] = 1;
    $new_max_min_res[1][3] = 1;
  }

  for($level=$hierarchy;$level>0;$level--) {
    if($_[0] ne "joint") {
      @new_pos = @new_pos_res;
      &printbug($afficheTrans,"NEW_POS",@new_pos);
      
      $new_level = ($level-1)*4;
      @level_transform = (@transforms[$new_level],@transforms[$new_level+1],@transforms[$new_level+2],@transforms[$new_level+3]);
      
      &printbug($afficheTrans,"LEVEL_TRANSFORM (avant mprod -> NEWPOS)",@level_transform);
      
      @new_pos_res = mprod(@level_transform,@new_pos);
      &printbug($afficheTrans,"NEW_POS_RES",@new_pos_res);
    
      @new_max_min = @new_max_min_res;
      &printbug($afficheVProd,"NEW_MAX_MIN",@new_max_min);
      &printbug($afficheVProd,"NEW_MAX_MIN_RES",@new_max_min_res);
      @new_max_min_res = vprod(@level_transform,@new_max_min);
    } elsif($level == 1) {
      @origin_goal = @origin_goal_res;
      &printbug($afficheVProd,"ORIGIN_GOAL",@origin_goal);
      &printbug($afficheVProd,"ORIGIN_GOAL_RES",@origin_goal_res);
      $new_level = 0;
      @level_transform = (@transforms[$new_level],@transforms[$new_level+1],@transforms[$new_level+2],@transforms[$new_level+3]);
      @origin_goal_res = vprod(@level_transform,@origin_goal);
    }
  }

  if($_[0] ne "joint") {
    @new_pos = @new_pos_res;
    @new_pos_res = mprod(&rand_axe(1,0,0,$PI2),@new_pos);
    @new_pos = @new_pos_res;
    @new_pos_res = mprod(&rand_axe(0,0,1,$PI2),@new_pos);

    @new_max_min = @new_max_min_res;
    @new_max_min_res =  vprod(&rand_axe(1,0,0,$PI2),@new_max_min);
    @new_max_min = @new_max_min_res;
    @new_max_min_res =  vprod(&rand_axe(0,0,1,$PI2),@new_max_min);
    
    for($bb_coord=0;$bb_coord<3;$bb_coord++) {
      if($new_max_min_res[0][$bb_coord]<$new_max_min_res[1][$bb_coord]) {
	$temp = $new_max_min_res[0][$bb_coord];
	$new_max_min_res[0][$bb_coord] = $new_max_min_res[1][$bb_coord];
	$new_max_min_res[1][$bb_coord] = $temp;
      }
      push(@bounding_boxes,$new_max_min_res[0][$bb_coord]);
      &printbug2($afficheVProd,"BBS (1)",@bounding_boxes);
      push(@bounding_boxes,$new_max_min_res[1][$bb_coord]);
      &printbug2($afficheVProd,"BBS (2)",@bounding_boxes);
    }
  } else {
    @origin_goal = @origin_goal_res;
    @origin_goal_res = vprod(&rand_axe(1,0,0,$PI2),@origin_goal);
    @origin_goal = @origin_goal_res;
    @origin_goal_res = vprod(&rand_axe(0,0,1,$PI2),@origin_goal);

    local($max_value) = 0;
    local(@temp_values) = ();
    for($i=0;$i<3;$i++) {
      $temp_value[$i] = abs($origin_goal_res[1][$i]-$origin_goal_res[0][$i]);
      if($temp_value[$i]>$max_value) {
	$max_value = $temp_value[$i];
      }	
      $jnt_po[$i] = (abs($origin_goal_res[0][$i])<$epsilon) ? 0 : int($origin_goal_res[0][$i]/$epsilon)*$epsilon;
    }
    #@jnt_po = ($origin_goal_res[0][0],$origin_goal_res[0][1],$origin_goal_res[0][2]);
    #@jnt_rot = ($origin_goal_res[1][0]-$jnt_po[0],$origin_goal_res[1][1]-$jnt_po[1],$origin_goal_res[1][2]-$jnt_po[2],$jnt_rot[3]);
    for($i=0;$i<3;$i++) {
      $jnt_rot[$i] = (abs($temp_value[$i]/$max_value)<$epsilon) ? 0 : int($temp_value[$i]/$max_value/$epsilon)*$epsilon;
    }
  }
}



##
##  BOX
##
sub box_sub {
  #ligne du "Box"
  @size = (2,2,2);
  $stop_box = 0;

  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/\bsize$border\s+($number)\s+($number)\s+($number)/) {
#DEBUG
$afficheNone or print BUG "size $inputnb\n";
        #ligne du "size x y z"
        @size = ($1,$2,$3);
    }
    if(/$close_bracket/) {
#DEBUG
$afficheNone or print BUG "box\t$1\n $inputnb\n";
      &by_mat_sub("box",0);

      if($filetype eq 'r') {
	if($h_anim) {
	  push(@body_names,"$env_name-$box_name");
	} elsif(@body_nb_poly) {
	  ($body_nb_poly[$#body_nb_poly])++;
	}
      }
	
      print MACRO "\n    p3d_add_desc_box $box_name $size[0] $size[1] $size[2]\n";
      print MACRO "    p3d_set_prim_pos_by_mat $box_name";
      for($i=0;$i<4;$i++) {
        for($j=0;$j<4;$j++) {
          $by_mat_elt = $new_pos_res[$i][$j];
          print MACRO " $by_mat_elt";
        }
      }
      print MACRO "\n";
      if($h_anim && ($filetype eq 'r')) {
	$add_jnt = 1;
      }
      $compteur += 2;
      #ligne du "}" du 'Box'
      $stop_box = 1; 
#DEBUG
$afficheNone or print BUG "box:\tstop_box = $stop_box\n";
$afficheNone or print BUG "box_sub fini\t$inputnb\n\n";
    }
    
    unless($stop_box){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "BOX: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_box);
  $_
}


##
##  SPHERE
##
sub sphere_sub {
  #ligne du "Sphere"
  $radius = 1;
  $stop_sphere = 0;

  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/\bradius$border\s+($number)/) {
#DEBUG
$afficheNone or print BUG "radius $inputnb\n";
        #ligne du "radius r"
        $radius = $1;
    }
    if(/$close_bracket/) {
#DEBUG
$afficheNone or print BUG "sphere\t$1\n $inputnb\n";
      &by_mat_sub("sphere",0);
      
      if($filetype eq 'r') {
	if($h_anim) {
	  push(@body_names,"$env_name-$sphere_name");
	} elsif(@body_nb_poly) {
	  ($body_nb_poly[$#body_nb_poly])++;
	}
      }

      print MACRO "\n    p3d_add_desc_sphere $sphere_name $radius\n";
      print MACRO "    p3d_set_prim_pos_by_mat $sphere_name";
      for($i=0;$i<4;$i++) {
        for($j=0;$j<4;$j++) {
          $by_mat_elt = $new_pos_res[$i][$j];
          print MACRO " $by_mat_elt";
        }
      }
      print MACRO "\n";
      if($h_anim && ($filetype eq 'r')) {
	$add_jnt = 1;
      }
      $compteur += 2;
      #ligne du "}" du 'Sphere'
      $stop_sphere = 1; 
#DEBUG
$afficheNone or print BUG "sphere:\tstop_sphere = $stop_sphere\n";
$afficheNone or print BUG "sphere_sub fini\t$inputnb\n\n";
    }
    
    unless($stop_sphere){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "SPHERE: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_sphere);
  $_;
}


##
##  CYLINDRE
##
sub cylinder_sub {
  #ligne du "Cylinder"
  $radius = 1;
  $height = 2;
  $stop_cylinder = 0;
$afficheNone or print BUG "cylindre_name = $cylinder_name\n";
  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/\bradius$border\s+($number)/) {
#DEBUG
$afficheNone or print BUG "radius $inputnb\n";
        #ligne du "radius r"
        $radius = $1;
    }
    if(/\bheight$border\s+($number)/) {
#DEBUG
$afficheNone or print BUG "height $inputnb\n";
        #ligne du "height h"
        $height = $1;
    }
    if(/$close_bracket/) {
#DEBUG
$afficheNone or print BUG "cylindre:\t$1 $inputnb\n";
      &by_mat_sub("cylinder",1);

     if($filetype eq 'r') {
	if($h_anim) {
	  push(@body_names,"$env_name-$cylinder_name");
	} elsif(@body_nb_poly) {
	  ($body_nb_poly[$#body_nb_poly])++;
	}
      }

      print MACRO "\n    p3d_add_desc_cylindre $cylinder_name $radius $height\n";
      print MACRO "    p3d_set_prim_pos_by_mat $cylinder_name";
      for($i=0;$i<4;$i++) {
        for($j=0;$j<4;$j++) {
          $by_mat_elt = $new_pos_res[$i][$j];
          print MACRO " $by_mat_elt";
        }
      }
      print MACRO "\n";
      if($h_anim && ($filetype eq 'r')) {
	$add_jnt = 1;
      }
      $compteur += 2;
      #ligne du "}" du 'Cylinder'
      $stop_cylinder = 1; 
#DEBUG
$afficheNone or print BUG "cylindre:\tstop_cylinder = $stop_cylinder\n";
$afficheNone or print BUG "cylinder_sub fini\t$inputnb\n\n";
    }
    unless($stop_cylinder){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "CYLINDRE: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_cylinder);
  $_;
}


##
##  CONE
##
sub cone_sub {
  #ligne du "Cone"
  $bottomRadius = 1;
  $height = 2;
  $stop_cone = 0;
$afficheNone or print BUG "cone_name = $cone_name\n";
  do { 
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/\bbottomRadius$border\s+($number)/) {
#DEBUG
$afficheNone or print BUG "bottomRadius $inputnb\n";
        #ligne du "bottomRadius r"
        $bottomRadius = $1;
    }
    if(/\bheight$border\s+($number)/) {
#DEBUG
$afficheNone or print BUG "height $inputnb\n";
        #ligne du "height h"
        $height = $1;
    }
    if(/$close_bracket/) {
#DEBUG
$afficheNone or print BUG "cone:\t$1 $inputnb\n";
      &by_mat_sub("cone",1);

      if($filetype eq 'r') {
	if($h_anim) {
	  push(@body_names,"$env_name-$cone_name");
	} elsif(@body_nb_poly) {
	  ($body_nb_poly[$#body_nb_poly])++;
	}
      }

      local($diameter) = 2*$bottomRadius;
      print MACRO "\n    p3d_add_desc_cone $cone_name 0.0 $diameter $height\n";
      print MACRO "    p3d_set_prim_pos_by_mat $cone_name";
      for($i=0;$i<4;$i++) {
        for($j=0;$j<4;$j++) {
          $by_mat_elt = $new_pos_res[$i][$j];
          print MACRO " $by_mat_elt";
        }
      }
      print MACRO "\n";
      if($h_anim && ($filetype eq 'r')) {
	$add_jnt = 1;
      }
      $compteur += 2;
      #ligne du "}" du 'Cone'
      $stop_cone = 1; 
#DEBUG
$afficheNone or print BUG "cone:\tstop_cone = $stop_cone\n";
$afficheNone or print BUG "cone_sub fini\t$inputnb\n\n";
    }
    unless($stop_cone){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "CONE: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_cone);
  $_;
}


##
##  BOUNDING BOX
##
sub xtreme_coord_update {
#DEBUG
$NoXtreme or print BUG "UPDATE...";
  @xtreme_coord = (-$max,-$max,-$max,$max,$max,$max);
  @xtreme_index = (0,0,0,0,0,0);
  local(@indexes_read) = (1) x(($#coord+1)/3);
  local(@current) = ();

  for($indx=0;$indx<=$#coordIndex;$indx++) {
    $real_index = $coordIndex[$indx];
    if($real_index && $indexes_read[$real_index-1]) {
      $indexes_read[$real_index-1] = 0;
      $real_index_shift = 3*($real_index - 1);
      @current = ($coord[$real_index_shift],$coord[$real_index_shift+1],$coord[$real_index_shift+2]);
#DEBUG
$NoXtreme or print BUG "coordTAB = @coord\ncurrent = @current\n";
      for($i=0;$i<3;$i++) {
	if($current[$i] > $xtreme_coord[$i]) { 
	  $xtreme_coord[$i] = $current[$i];
	  $xtreme_index[$i] = $real_index;
#DEBUG
$NoXtreme or print BUG "MAX ($last_name)= {@xtreme_coord} {@xtreme_index}\n";
	}

	if($current[$i] < $xtreme_coord[$i+3]) { 
	  $xtreme_coord[$i+3] = $current[$i];
	  $xtreme_index[$i+3] = $real_index;
#DEBUG
$NoXtreme or print BUG "MIN ($last_name)= {@xtreme_coord} {@xtreme_index}\n";
	}
      }
    }
  }
#DEBUG
$NoXtreme or print BUG "UPDATE FINIE";
}


##
##  NORMALE VALIDE ?
##
sub check_normal {

  $NoNormal or print "\nCheck normals...\n";  

  $not_singular = 6;
  $no_exception = 0;
  local(@reverse_yes) = (0,0);

$NoNormal or print BUG "check_normal: xtreme_index = @xtreme_index\n"; 
for($xi=0;$xi<=$#xtreme_index;$xi++) { $NoNormal or print BUG "check_normal: xtreme_coord ($xtreme_index[$xi]) = $coord[3*($xtreme_index[$xi]-1)] $coord[3*($xtreme_index[$xi]-1)+1] $coord[3*($xtreme_index[$xi]-1)+2]\n"; }
  while($not_singular) {
    $next_vert = 0;    
    SINGULAR: while(1) {
      local(@xtreme_index_temp)=();
      local(@xtreme_index3)=();
$NoNormal or print BUG "check_normal: coordIndexTAB = @coordIndex\n";
      while(($next_vert <= $#coordIndex) && ($coordIndex[$next_vert] != $xtreme_index[$not_singular-1])) { 
$NoNormal or print BUG "check_normal: coordIndex = $coordIndex[$next_vert] DIFFERENT DE XTI = $xtreme_index[$not_singular-1] ?\n";
	$next_vert++;
      }
      if($next_vert > $#coordIndex) {
	$not_singular--;
	($reverse_yes[0] > 0) ? ($reverse_yes[1]++) : ($reverse_yes[1]--);
	$reverse_yes[0] = 0;
$NoNormal or print BUG "check_normal: Fin du vote dans $not_singular... {@reverse_yes}\n";
	last SINGULAR;
      }
$NoNormal or print BUG "check_normal: next_vert = $next_vert\tnot_singular = $not_singular\n";
      while($coordIndex[$next_vert]) { $next_vert--; }
      $next_vert++;
$NoNormal or print BUG "check_normal: next_vert = $next_vert\tnot_singular = $not_singular\n";
      while($coordIndex[$next_vert]) {
	push(@xtreme_index_temp,$coordIndex[$next_vert]);
	$next_vert++;
      }
$NoNormal or print BUG "check_normal: XIT = @xtreme_index_temp\n";
      @xtreme_index3 = (@xtreme_index_temp,@xtreme_index_temp,@xtreme_index_temp);
$NoNormal or print BUG "check_normal: XIT3 = @xtreme_index3\n";

      $first_occ = 1;
      $next_index = 0;
      while(($xtreme_index3[$next_index] != $xtreme_index[$not_singular-1]) || $first_occ) {
	if($xtreme_index3[$next_index] == $xtreme_index[$not_singular-1]) { $first_occ = 0; }
	$next_index++;
      }
      local(@vect1)=();
      local(@vect2)=();
      $index = ($xtreme_index3[$next_index]-1)*3;
      $index1 = ($xtreme_index3[$next_index+1]-1)*3;
      $index2 = ($xtreme_index3[$next_index-1]-1)*3;
$NoNormal or print BUG "check_normal: indexes { , 1, 2} = {$index, $index1, $index2}\n";
      for($i=0;$i<3;$i++) {
	$vect1[$i] = $coord[$index1+$i]-$coord[$index+$i];
	$vect2[$i] = $coord[$index2+$i]-$coord[$index+$i];
      }
$NoNormal or print BUG "check_normal: vect1 = @vect1\n";
$NoNormal or print BUG "check_normal: vect2 = @vect2\n";
      local(@face_normal)=();
      $face_normal[0]=$vect1[1]*$vect2[2]-$vect1[2]*$vect2[1];
      $face_normal[1]=$vect1[2]*$vect2[0]-$vect1[0]*$vect2[2];
      $face_normal[2]=$vect1[0]*$vect2[1]-$vect1[1]*$vect2[0];
$NoNormal or print BUG "check_normal: face_normal = @face_normal\n";

      $shift_left = ($not_singular>3) ? 4 : 1;
      if($face_normal[$not_singular-$shift_left]) { 
	$no_exception = 1;
$NoNormal or print BUG "check_normal: $face_normal[$not_singular-$shift_left] NON NULLE ?\n";
	$test = ($not_singular>3) ? ($face_normal[$not_singular-$shift_left] > 0) : ($face_normal[$not_singular-$shift_left] < 0) ;
	($test) ? ($reverse_yes[0]++) : ($reverse_yes[0]--);
$NoNormal or print BUG "check_normal: reverse_yes = @reverse_yes\n";
$NoNormal or print BUG "check_normal: inversion = $reverse_faces ?\n";
$NoNormal or print BUG "check_normal: REDO\n";
	redo SINGULAR;
      } else {
$NoNormal or print BUG "check_normal: Cas particulier (REDO)\n";
	redo SINGULAR;
      }
    }
  }
$NoNormal or print BUG "check_normal : reverse_faces(avant MAJ / scales) = $reverse_faces\n";
  $reverse_faces = ($reverse_yes[1] > 0) ? -1 : 1; 
  for($inversion=0;$inversion<$hierarchy;$inversion++) {
    $reverse_faces *= $hierarchy_inversions[$inversion];
$NoNormal or print BUG "check_normal($inversion): $hierarchy_inversions[$inversion]\n";
$NoNormal or print BUG "check_normal : reverse_faces  ($inversion) = $reverse_faces\n";
  }
$NoNormal or print BUG "check_normal fini\n";
}


##
##  INDEXED_FACE_SET
##
sub indexedFaceSet_sub {
  #ligne du "IndexedFaceSet"  
  $stop_indexedFaceSet = 0;
  $no_use_indexedFaceSet = 0;
  $ccw = 1;
  $solid = 1;

  do {
    if(/^\s*\#/ || /^\s*$/) {
      COMMENTS: while(/^\s*\#/ || /^\s*$/) {
	$_=<INPUT>;
	unless($_) {last COMMENTS;}
	$inputnb++;
	$NoConsole or print "line $inputnb read\t$faces faces\n";
	$percent = int(1000*$inputnb/$total_lines)/10;
	$NoPercent or print "$percent % of $inputfile read      \r";
	($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    }

    if(/$open_bracket/) {
      #cas:color|colorIndex|normal|normalIndex|textCoord|texCoordIndex
      $no_use_indexedFaceSet++;
#DEBUG
$afficheNone or print BUG "no_use_indexedFaceSet++ = $no_use_indexedFaceSet\t$inputnb\n";
    }   

    if(/\bccw$border\s+FALSE/) {
#DEBUG
$NoNormal or print BUG "\n\nCCW = FALSE\t$inputnb\n\n\n";
      $ccw = 0;
    }
    if(/\bsolid$border\s+FALSE/) {
#DEBUG
$NoNormal or print BUG "\n\nSOLID = FALSE\t$inputnb\n\n\n";
      $solid = 0;
    }

    if(/\bcoord$border/) { 
      #ligne du "coord"
#DEBUG
$afficheNone or print BUG "coord $inputnb\n";
      unless(/$open_bracket/) { $no_use_indexedFaceSet++; } #prise en compte du "Coordinate {"
      $_ = &build_coord;
    }
    if(/\bcoordIndex$border/) { 
      #ligne du "coordIndex"
#DEBUG
$afficheNone or print BUG "coordIndex $inputnb\n";
      $_ = &build_coordIndex;
    }

    if(/$close_bracket/) {
#DEBUG
$afficheNone or print BUG "indexedFaceSet:\t$1 $inputnb\n";
      $no_use_indexedFaceSet--;
      unless($no_use_indexedFaceSet) {
#DEBUG
$afficheNone or print BUG "indexedFaceSet:Construction...\n";
        $stop_indexedFaceSet = 1;
        #ligne du "}" du 'IndexedFaceSet'
#DEBUG
$afficheNone or print BUG "indexedFaceSet:Taille de COORDINDEX = $#coordIndex\n";
        if(@coordIndex > 2) {
	  $empty_macro = 0;
	  if($filetype eq 'r') {
	    if($h_anim) {
	      push(@body_names,"$env_name-$indexedFaceSet_name");
	    } elsif(@body_nb_poly) {
	      ($body_nb_poly[$#body_nb_poly])++;
	    }
	  }

	  print MACRO "\n    p3d_add_desc_poly $indexedFaceSet_name\n";
	  $compteur++;
	  for($i=0;$i<(($#coord+1)/3);$i++) {
	    print MACRO "      p3d_add_desc_vert $coord[3*$i] $coord[3*$i+1] $coord[3*$i+2]\n";
	    $compteur++;
	  }
	  print MACRO "\n";
	  
	  # MAJ de @xtreme_coord
#DEBUG
$NoNormal or print BUG "UPDATE (IFS)\n";
	  &xtreme_coord_update;
#DEBUG
$NoNormal or print BUG "UPDATE (IFS)\n";

	  ## NORMALES VALIDES ?
	  unless($solid && $ccw) { &check_normal; }
	  unless($no_exception) {
	    print MACRO "# WARNING: Normal inversions possible\n";
	    print OUTPUT "# WARNING: Normal inversions possible\n";
	    $exception = 1;
	  }
	  
	  $create_face = 1;
	  $next_vert = 0;	
	  while($create_face) {
	    local(@new_face) = ();   
#DEBUG
$afficheNone or print BUG "indexedFaceSet: Boucle create\t$inputnb\n";
	    while($coordIndex[$next_vert]) {
#DEBUG
#$afficheNone or print BUG "indexedFaceSet: Boucle push\t$inputnb\n";
	      push(@new_face,$coordIndex[$next_vert++]);
#DEBUG
$afficheNone or print BUG "indexedFaceSet: $coordIndex[$next_vert-1] pushed\t$inputnb\n";
	    }

	    local(@new_face_rev) = reverse(@new_face);
	    print MACRO "      p3d_add_desc_face";
	    for($i=0;$i<=$#new_face;$i++) {
	      if($solid && $ccw) { 
		print MACRO " $new_face[$i]";
#DEBUG
$NoNormal or print BUG "S & CCW -> nR\n";
	      } else {
	        if($reverse_faces < 0) {
		  print MACRO " $new_face_rev[$i]";
#DEBUG
$NoNormal or print BUG "nS | nCCW -> R\n";
		} else {
		  print MACRO " $new_face[$i]";
#DEBUG
$NoNormal or print BUG "ns | nCCW -> nR\n";
		}
	      }
	    }
	    $faces++;

#DEBUG
#$afficheNone or print BUG "new_face[] = $new_face_checked[$i]\t$inputnb\n";
	    $compteur++;;
	    print MACRO "\n";
	    
	    $next_vert++;
	    if($next_vert > $#coordIndex) {
	      $create_face = 0;
#DEBUG
$afficheNone or print BUG "All faces done\tnext_vertex = $next_vertex\t$inputnb\n";
	    }
	  }
	  
	  print MACRO "    p3d_end_desc_poly\n";

	  &by_mat_sub("IFS",0);
	  
	  print MACRO "    p3d_set_prim_pos_by_mat $indexedFaceSet_name";
	  for($i=0;$i<4;$i++) {
	    for($j=0;$j<4;$j++) {
	      $by_mat_elt = $new_pos_res[$i][$j];
	      print MACRO " $by_mat_elt";
	    }
	  }
	  print MACRO "\n";
	  if($h_anim && ($filetype eq 'r')) {
	    $add_jnt = 1;
	  }
	  $compteur += 3;
	      
	  while(@coordIndex) { pop(@coordIndex); }
	  while(@coord) { pop(@coord); }
#DEBUG
$afficheNone or print BUG "indexedFaceSet:Construction finie\n";
	} else {
	  splice(@colorsRGB,$#colorsRGB-2,3);
	  $NoErr or print "indexedFaceSet:NON CONSTRUITE\n";
	}
      }
#DEBUG
$afficheNone or print BUG "indexedFaceSet: stop_indexedFaceSet = $stop_indexedFaceSet\n";
if($stop_geometry){$afficheNone or print BUG "no_use_indexedFaceSet = 0 = $no_use_indexedFaceSet\tindexedFaceSet_sub fini\t$inputnb\n";}else{$afficheNone or print BUG "no_use_indexedFaceSet-- = $no_use_indexedFaceSet\t$inputnb\n";}
    }

    unless($stop_indexedFaceSet){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "INDEXED_FACE_SET: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_indexedFaceSet);
  $_;
}


##
##  COORD
##
sub build_coord {
  #ligne du "coord"
  @coord = ();
  $stop_coord = 1; 
  $stop_point = 1;
  do {
#DEBUG
$afficheNone or print BUG "Boucle Coord\t$inputnb\n"; 
    if($stop_coord) {
      do {
	if($stop_point && /\[(.*[\n\r])/) { 
	  $_ = "$1";
	  $stop_point = 0;
	} else {
	  while($stop_point) {
	    $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "COORDINDEX: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
	    if(/\[(.*[\n\r])/) {
	      $_ = "$1";
	      $stop_point = 0;
	    }
	  }
	}
	if(($stop_point-1) && /^(\s*\])(.*[\n\r])/) {
	  $_ = "$1$2";
	  $stop_point = 1;
	  $stop_coord = 0;
	}
        NEWVERTEX: while(($stop_point-1) && /\s*($number)\s+($number)\s+($number)\s*([\,\]]?)(.*[\n\r])/) {
	    if($4 eq "\]") {
	      $_ = "$4$5";
	      $stop_point = 1;
	      $stop_coord = 0;
	      push(@coord,($1,$2,$3));
#DEBUG
$afficheNone or print BUG "push @coord\n";
	      #ligne du "]" du 'point'
	      last NEWVERTEX;
	    } else {
	      $_ = "$5";      
	      push(@coord,($1,$2,$3));
#DEBUG
$afficheNone or print BUG "push @coord\n";
	    }
	  }
      
	unless($stop_point){
	  $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "POINT (COORD): ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
	}
      } until($stop_point);
    }

    if(/$close_bracket/) { 
#DEBUG
$afficheNone or print BUG "coord:\t$1 $inputnb\n";
      $stop_coord = 1;
      #ligne du "}" du 'coord'
    }

    unless($stop_coord) {
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "COORD: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_coord);
  $_;
}


##
##  COORDINDEX
##
sub build_coordIndex {
  #ligne du "coordIndex"
  @coordIndex = ();
  $stop_coordIndex = 1;

  do {
#DEBUG
$afficheNone or print BUG "Boucle CoordIndex\t$inputnb\n";
    if($stop_coordIndex && /\[(.*[\n\r])/) { 
      $_ = "$1";
      $stop_coordIndex = 0;
    } else {
      while($stop_coordIndex) {
	$_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "COORDINDEX: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
	if(/\[(.*[\n\r])/) {
	  $_ = "$1";
	  $stop_coordIndex = 0;
	}
      }
    }
    if(($stop_coordIndex-1) && /^(\s*\])(.*[\n\r])/) {
      $_ = "$1$2";
      $stop_coordIndex = 1;
    }
    NEWINDEX: while(($stop_coordIndex-1) && /\s*($number)\s*([\,\]]?)(.*[\n\r])/) {
	if($2 eq "\]") {
	  $_ = "$2$3";
	  $stop_coordIndex = 1;
	  push(@coordIndex,$1+1);
#DEBUG
$afficheNone or print BUG "push @coordIndex\n";
	  #ligne du "]" du 'coordIndex'
	  last NEWINDEX;
	} else {
	  $_ = "$3";      
	  push(@coordIndex,$1+1);
#DEBUG
$afficheNone or print BUG "push @coordIndex\n";
	}
    }

    unless($stop_coordIndex){
      $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "COORDINDEX: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  } until($stop_coordIndex);
  $_;
}


##
##  CENTRER DANS LE REPERE GLOBAL
##

sub global_translate {
  
  &printbug2($afficheVProd,"BBS (GLOBAL)",@bounding_boxes);
  $bb_nb = ($#bounding_boxes+1)/6;
  $zmin = $max;
  $zmin_rec = 1;
  local(@ground_centers) = ();
  for($bb=0;$bb<$bb_nb;$bb++) {
    $zmin_index = 6*$bb+5;
    if(abs($bounding_boxes[$zmin_index] - $zmin) < $epsilon) {
      $zmin_rec++;
      push(@ground_centers,($bounding_boxes[$zmin_index-5]+$bounding_boxes[$zmin_index-4])/2);
      push(@ground_centers,($bounding_boxes[$zmin_index-3]+$bounding_boxes[$zmin_index-2])/2);	      
    }
    if($bounding_boxes[$zmin_index] < ($zmin-$epsilon)) {
      $zmin=$bounding_boxes[$zmin_index];
      $zmin_rec = 1;
      while(@ground_centers) { pop(@ground_centers); }
      $ground_centers[0] = ($bounding_boxes[$zmin_index-5]+$bounding_boxes[$zmin_index-4])/2;
      $ground_centers[1] = ($bounding_boxes[$zmin_index-3]+$bounding_boxes[$zmin_index-2])/2;
    }
    &printbug2($Global,"GROUND CENTERS",@ground_centers);
    $NoGlobal or print BUG "\nzmin = $zmin\tzmin_rec = $zmin_rec";
  }
  local(@global_translation) = ($ground_centers[0],$ground_centers[1],$zmin);
  &printbug2($Global,"GLOBAL TRANSLATION",@global_translation);
  for($rec=1;$rec<$zmin_rec;$rec++) {
    $global_translation[0] += $ground_centers[2*$rec];
    $global_translation[1] += $ground_centers[2*$rec+1];	  
    &printbug2($Global,"GLOBAL TRANSLATION (barycentre...)",@global_translation);
  }
  $global_translation[0] /= $zmin_rec;
  $global_translation[1] /= $zmin_rec;
  &printbug2($Global,"GLOBAL TRANSLATION (barycentre)",@global_translation);
  
  close(MACRO) or die "\nCannot close macro file $last_name.macrotmp";
  open(MACRO, ">".$last_name.".macro") or die "\nCannot create macro file $last_name.macro\n";
  open(MACROTMP, $last_name.".macrotmp") or die "\nCannot open macro file $last_name.macrotmp\n";
  local(@relative_pos) = ([1,0,0,-$global_translation[0]],[0,1,0,0,-$global_translation[1]],[0,0,1,-$global_translation[2]],[0,0,0,1]);
  local($next_body) = 0;
  local($nb_body_pipo) = 0;
  local($this_body_pipo) = 0;
  local($current_body) = 0;
  local($last_current_body) = 1;
  local($rec_jnt) = 0;
  local(@jntmap) = (0,1);
  local($kine) = 2;
  local($kine_change) = 0;
  local($pipo_follow) = 0;
  local(@previous_pos) = (-$global_translation[0],-$global_translation[1],-$global_translation[2]);

  if(($filetype eq 'r') || $humanoid_definition) { unless($nb_jnt) { $nb_jnt = 2; }}

  while(<MACROTMP>) {
    if(/p3d_set_prim_pos_by_mat\s+($name)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)/) {
      local(@last_pos) = ([$2,$3,$4,$5],[$6,$7,$8,$9],[$10,$11,$12,$13],[$14,$15,$16,$17]);
      &build_translation(-$global_translation[0],-$global_translation[1],-$global_translation[2]);
      @relative_pos = mprod(@translation,@last_pos);
      &printbug($Global,"relative_pos",@relative_pos);
      print MACRO "    p3d_set_prim_pos_by_mat $1";
      for($l=0;$l<4;$l++) {
	for($c=0;$c<4;$c++) {
	  $relative_pos[$l][$c] = (abs($relative_pos[$l][$c])<$epsilon) ? 0 : int($relative_pos[$l][$c]/$epsilon)*$epsilon;
	  print MACRO " $relative_pos[$l][$c]";
	}
      }
      print MACRO "\n";
#print MACRO $_ #ATTENTION GLOBAL
    } elsif((($filetype eq 'r') || $humanoid_definition) && /p3d_add_desc_jnt P3D_ROTATE\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+($number)\s+(PIPO)?/) { 
      if($next_body <= $#body_names) {      
	local(@global_pos) = ($1,$2,$3);
	local($same_pos) = 0;

	for($i=0;$i<3;$i++) {
	  $global_pos[$i] += ($h_anim && ($humanoid_definition-1)) ?  $relative_pos[$i][3] : (-$global_translation[$i]);
	  $global_pos[$i] = (abs($global_pos[$i])<$epsilon) ? 0 : int($global_pos[$i]/$epsilon)*$epsilon;
	}
#@next_jnt_sphere = @global_pos;      
	
	if($10 < 2) {
	  print MACRO "  p3d_add_desc_jnt P3D_ROTATE $global_pos[0] $global_pos[1] $global_pos[2]  $4 $5 $6 $7 $8 $9 $10\n";
	  if($h_anim && ($10 == 1)) {
	    print MACRO "\n";
	    $pipo_follow = 1;
	  }
	} else {
	  if($11 || $pipo_follow) { 
	    print MACRO "  p3d_beg_desc P3D_BODY $body_names[$next_body]_pipo$rec_jnt\n";
	    $compteur++;
	    $rec_jnt++;
	  }
	  print MACRO "  p3d_end_desc\n\n";
	  $compteur++;
	  
	  if($h_anim) {
	    local($mod) = ($nb_jnt-2)%9;
	    $current_body = ($mod) ? $nb_jnt : 2;
	  } else {
	    if($10 == $kine) {
	      $kine++;
	      $current_body = $last_current_body + 1;
	      if($#jntmap < $10) { push(@jntmap,$current_body); }
	      $kine_change = 0;
	      $same_pos = ($previous_pos[0] == $1) && ($previous_pos[1] == $2) && ($previous_pos[2] == $3);
	    } else {
	      $kine = $10+1;
	      while($#jntmap>$10) { pop(@jntmap); }
	      $current_body = ($h_anim) ? ($10+$nb_body_pipo) : $jntmap[$10];
	      $kine_change = 1;
	      $same_pos = 0;
	    }
	    @previous_pos = ($1,$2,$3);
	  }
	  
	  local(@llimit) = (-180.0,-180.0,-180.0);
	  local(@ulimit) = (180.0,180.0,180.0);
	  unless($h_anim) { 
	    @llimit = splice(@jnt_llimit,0,3);
	    @ulimit = splice(@jnt_ulimit,0,3);
	  }
$AfficheNone or print BUG "llimit = #@llimit#\n";
$AfficheNone or print BUG "ulimit = #@ulimit#\n";

	  unless($no_spherical || ($pipo_follow && $same_pos)) {
	    $nb_jnt++;
	    print MACRO "  p3d_add_desc_jnt P3D_ROTATE $global_pos[0] $global_pos[1] $global_pos[2]  1.0 0.0 0.0 0.0 $llimit[0] $ulimit[0] $current_body #$10 ##$nb_jnt\n\n";
	    $compteur++;
	    $nb_body_pipo++;
	    print MACRO "  p3d_beg_desc P3D_BODY $body_names[$next_body].$body_names[$next_body]_$rec_jnt-X\n"; #$this_body_pipo\n";
	    print MACRO "  p3d_end_desc\n\n";
	    $compteur += 2;
	    
	    $nb_jnt++;
	    if($h_anim) {
	      $current_body = $nb_jnt-1;
	    } else {
	      $current_body = ($kine_change) ? ($last_current_body+2) : ($current_body+1);
	    }
	    print MACRO "  p3d_add_desc_jnt P3D_ROTATE $global_pos[0] $global_pos[1] $global_pos[2]  0.0 1.0 0.0 0.0 $llimit[1] $ulimit[1] $current_body ##$nb_jnt\n\n";
	    $compteur++;
	    
	    $nb_body_pipo++;
	    print MACRO "  p3d_beg_desc P3D_BODY $body_names[$next_body].$body_names[$next_body]_$rec_jnt-Y\n"; #$this_body_pipo\n";
	    print MACRO "  p3d_end_desc\n\n";
	    $compteur += 2;

	    unless($h_anim) {
	      $nb_jnt++;
	      $current_body++;
	      print MACRO "  p3d_add_desc_jnt P3D_ROTATE $global_pos[0] $global_pos[1] $global_pos[2]  0.0 0.0 1.0 0.0 $llimit[2] $ulimit[2] $current_body ##$nb_jnt\n\n";
	      $compteur++;
	      
	      $nb_body_pipo++;
	      print MACRO "  p3d_beg_desc P3D_BODY $body_names[$next_body].$body_names[$next_body]_$rec_jnt-Z\n"; #$this_body_pipo\n";
	      print MACRO "  p3d_end_desc\n\n";
	      $compteur += 2;
	    }
	    $current_body++;
	  }
	  $nb_jnt++;
	  $last_current_body  = ($no_spherical) ? ($nb_jnt-1) : $current_body;
	  print MACRO "  p3d_add_desc_jnt P3D_ROTATE $global_pos[0] $global_pos[1] $global_pos[2]  $4 $5 $6 $7 $8 $9 $current_body #($10) ##$nb_jnt\n\n";

	  $pipo_follow = 1;
	}
      }
    } elsif($pipo_follow) {
      $pipo_follow = 0;
      $rec_jnt = 1;
      print MACRO "  p3d_beg_desc P3D_BODY $body_names[$next_body].$body_names[$next_body]\n";

#print MACRO "#\np3d_add_desc_sphere sphere$next_body 0.01\n";
#print MACRO "p3d_set_prim_pos sphere$next_body $next_jnt_sphere[0] $next_jnt_sphere[1] $next_jnt_sphere[2] 0 0 0\n#\n";

      $compteur++;
      $next_body++;
      (/^\s*$/) or print MACRO "$_";
    } else {      
      print MACRO "$_";
    }
  }
  while(@bounding_boxes) { pop(@bounding_boxes); }
  while(@jntmap) { pop(@jntmap); }

  close(MACROTMP) or die "\nCannot close macro file $last_name.macrotmp";
  $keeplink or unlink($last_name.".macrotmp");
  if(($filetype eq 'r') || $humanoid_definition) {
    $robot_name =  $last_name;
    for($i=0;$i<3;$i++) {
      $robot_global_translation[$i] = (abs($global_translation[$i])<$epsilon) ? 0 : int($global_translation[$i]/$epsilon)*$epsilon;
    }
    print OUTPUT "\n"; 
  } else {
    for($i=0;$i<3;$i++) {
      $global_translation[$i] = (abs($global_translation[$i])<$epsilon) ? 0 : int($global_translation[$i]/$epsilon)*$epsilon;
    }
    print OUTPUT "  p3d_set_obst_pos $last_name $global_translation[0] $global_translation[1] $global_translation[2] 0.0 0.0 0.0\n\n";
    $compteur++;
  }
  close(MACRO) or die "\nCannot close macro file $last_name.macro";
  $NoTracking or print "Macro created: $last_name.macro\n\n";
  $macro_nb++;
}



##
##  CREER UN NOUVEAU P3D_OBSTACLE/ROBOT/BODY
##

sub beg_desc_P3D {

  #CAS D'UN ROBOT
  if($filetype eq 'r') {
#DEBUG
$afficheNone or print BUG "Robot\t";
$afficheNone or print BUG "hierarchy = $hierarchy\t";
      
    if($is_first) {
      $is_first = 0;
      $the_name = "robot_$env_name";
      $last_name = $the_name;
      open(MACRO, ">".$the_name.".macrotmp") or die "\nCannot create macro file $the_name.macrotmp\n";
      $NoTracking or print "Macro in temp: $the_name.macro ...\n";
      print OUTPUT "  p3d_read_macro $the_name.macro $the_name\n";
      print MACRO "p3d_beg_desc P3D_ROBOT\n\n";
      print MACRO "  p3d_beg_desc P3D_BODY $the_name.freeflying\n";
      print MACRO "  p3d_end_desc\n\n"; 
      print MACRO "  p3d_add_desc_jnt P3D_ROTATE 0.0 0.0 0.0  1.0 0.0 0.0 0.0 -180.0 180.0 0\n";
      print MACRO "  p3d_add_desc_jnt P3D_ROTATE 0.0 0.0 0.0  0.0 1.0 0.0 0.0 -180.0 180.0 1";
      if($h_anim) { print MACRO" PIPO"; }
      print MACRO "\n\n";
  
      $compteur += 6;
#DEBUG
$afficheNone or print BUG "Si 0: TheName = $the_name\n";
    }
    if($h_anim) {
      $nb_body++;
      $the_name = "body".$nb_body;
      if($_[0]) { $the_name = "$_[1]"; }
      push(@previous_names,$the_name);
      if($_[2]) {
	print MACRO "  p3d_add_desc_jnt P3D_ROTATE 0.0 0.0 0.0  0.0 0.0 1.0 0.0 -180.0 180.0 2\n";
	$compteur++;
	$add_jnt = 0;
      }
    } else {
      if($add_pipo) { 
	print MACRO "  p3d_add_desc_jnt P3D_ROTATE $jnt_po[0] $jnt_po[1] $jnt_po[2]  $jnt_rot[0] $jnt_rot[1] $jnt_rot[2] $jnt_rot[3] -180.0 180.0 $jnt_hierarchy PIPO\n";
	$compteur++;
	$add_pipo = 0;
      } elsif($_[2]) {
	print MACRO "  p3d_add_desc_jnt P3D_ROTATE $jnt_po[0] $jnt_po[1] $jnt_po[2]  $jnt_rot[0] $jnt_rot[1] $jnt_rot[2] $jnt_rot[3] -180.0 180.0 $jnt_hierarchy\n";
	$compteur++;
	$add_jnt = 0;
      }
    }
  }

  #CAS D'UN OBSTACLE
  else {
#DEBUG
$afficheNone or print BUG "Obstacle\t";
$afficheNone or print BUG "hierarchy = $hierarchy\t";
      
    $the_name = "obstacle".$nb_obstacle;
    if($hierarchy || ($one_file_obstacle && ($is_first-1))) {
      if($_[0]) {
	$the_name = $last_name."_$_[1]";
      }
      elsif($#previous_names >= 0) {
	$the_name = "$previous_names[$#previous_names]";
      }
      else {
	$prev = $nb_obstacle - 1;
	$the_name = "obstacle".$prev;	  
      }
      push(@previous_names,$the_name);
    } else {      
      ($_[0]) ? ($the_name = $_[1]) : ($nb_obstacle++);
      if($is_first) {
	$is_first = 0;
      } else {
	if($empty_macro) {
	  close(MACRO);
	  $keeplink or unlink($last_name.".macrotmp");
	  push(@empty_macro_names,$last_name);
	} else {
	  print MACRO "\n  p3d_end_desc\n\n";
	  $compteur++;
	  ($humanoid_definition-1) or print MACRO "p3d_end_desc\n\n";
	  ($humanoid_definition-1) or ($poly_ref = 0);
	  ($humanoid_definition-1) or ($poly_index = 0);
	  
	  local(@splice_index) = ();
	  for($i=0;$i<=$#body_nb_poly;$i++) {
	    unless($body_nb_poly[$i]) {
	      push(@splice_index,$i);
	    }
	  }
	  for($i=0;$i<=$#splice_index;$i++) {
	    local($index) = $splice_index[$i]-$i;
	    splice(@body_names,$index,1);
	    splice(@body_nb_poly,$index,1);
	    splice(@colorsRGB,3*$index,3);
	  }
	  while(@splice_index) { pop(@splice_index); }

	  for($polynb=1;$polynb<=(@colorsRGB/3);$polynb++) {
	    $trichrom = 3*($polynb-1);
	    if($humanoid_definition) {
	      if($poly_ref == $body_nb_poly[$poly_index]) { 
		$poly_ref = 0;
		$poly_index++;
	      }
	      $poly_ref++;
	      print MACRO "p3d_set_body_poly_color $body_names[$poly_index].$body_names[$poly_index] $poly_ref "; 
	    } else {
	      print MACRO "p3d_set_obst_poly_color $polynb ";
	    }    
	    print MACRO "Any $colorsRGB[$trichrom] $colorsRGB[$trichrom+1] $colorsRGB[$trichrom+2]\n";
	    $compteur++;
	  }
	  while(@body_nb_poly) { pop(@body_nb_poly); }
	  while(@colorsRGB) { pop(@colorsRGB); }
	  while(@body_hierarchy) { pop(@body_hierarchy); }
	
	  if($DoNotGlobalTranslate && $h_anim) {
	    rename($last_name.".macrotmp",$last_name.".macro") or die "\nCannot rename file $last_name.macrotmp to $last_name.macro";
	    $macro_nb++;
	  } else {	  
	    &global_translate;
	    $humanoid_definition = 0;
	  }
	}
      }
      open(MACRO, ">".$the_name.".macrotmp") or die "\nCannot create macro file $the_name.macrotmp\n";
      $NoTracking or print "Macro in temp: $the_name.macro ...\n";
      print OUTPUT "  p3d_read_macro $the_name.macro $the_name\n";
      print MACRO "  p3d_beg_desc P3D_OBSTACLE\n\n"; #Macro!  $env_name.$the_name\n\n";
      $empty_macro = 1;
      while(@bounding_boxes) { pop(@bounding_boxes); }

      $compteur++;
      $last_name = $the_name;
#DEBUG
$afficheNone or print BUG "Si 0: TheName = $the_name\n";
    }
  }
}
 



   ################
 ###              ###
##       MAIN       ##
 ###              ###
   ################

##
##  PARAMETRES
##

if ($#ARGV != 2) {
  print "Usage:\tvrml2move3d -<filetype> <VRML filein> <MOVE3D fileout>\n";
  die "\tfiletype:\tr <--> robot\n\t\t\to <--> obstacle\n\t\t\to1 <--> obstacle (only one macro)\n";
}

$filetype = substr($ARGV[0],1,1);
$inputfile = $ARGV[1];
$outputfile = $ARGV[2];

$_ = $filetype;
unless(/$file_type/) {
  print "\nCannot read filetype \"$filetype\"\n\n";
  print "Usage:\twrl2p3d -<filetype> <VRML filein> <MOVE3D fileout>\n";
  die "\tfiletype:\tr <--> robot\n\t\t\to <--> obstacle\n\t\t\to1 <--> obstacle (only one macro file)\n";
}

if((length($ARGV[0])==3) && (substr($ARGV[0],2,2) eq '1')) {
  $one_file_obstacle = 1;
}

##
## INITIALISATION
##

$_ = $inputfile;
if(/$vrml_file/) {
  open(INPUT, $inputfile) or die "\nCannot open input file $inputfile\n";
} else {
  die "\nCannot open input file $inputfile\nFomat supported: .wrl & .wrz\n";
}

$point_index = rindex($inputfile,".");
$slash_index = rindex($inputfile,"/");
$inputfile = substr($inputfile,$slash_index+1,$point_index+4);
#print "\nslash_index = $slash_index\ninputfile = $inputfile\n";

$_ = <INPUT>;
unless(/^\#\bvrml$border[\s\w]+\bv2.0\b/i) {
  close(INPUT);
  die "\n$inputfile is not a VRML 2.0 file\nThis program convert only VRML 2.0 files\n\n";
}

#Nommer l'environnement
$point_index = rindex($outputfile,".");
$slash_index = rindex($outputfile,"/");
$dir_path = substr($outputfile,0,$point_index);
$env_name = substr($dir_path,$slash_index+1,$point_index);
#print "\npoint_index = $point_index\nslash_index = $slash_index\ndir_path = $dir_path\nenv_name = $env_name\n";

$_ = $outputfile;
if(/$move3d_file/) {
  $outputfile = $env_name.".p3d";
  if(-e $dir_path) { die "\nDirectory $dir_path already exists\nPlease change outputfile name\n\n"; }
  mkdir("$dir_path",0777) or die "\nCannot create directory $dir_path\n";
  chdir("$dir_path") or die "\nCannot cd to \\$dir_path\n";
  open(OUTPUT, ">".$outputfile) or die "\nCannot create output file $outputfile\n";
  mkdir("MACROS",0777) or die "\nCannot create directory $env_name\\MACROS\n";
  chdir("MACROS") or die "\nCannot cd to \\MACROS\n";  
} else {
  close(INPUT);
  die "\nCannot create output file $outputfile\nFomat supported: .p3d\n";
}
# INITIALISATION
print "\nCONVERSION ($filetype => ";
($filetype eq 'r') ? print "ROBOT" : print "OBSTACLE";
($one_file_obstacle) ? print " | 1 => 1 MACRO)\n" : print ")\n";
print "$inputfile -> $env_name.p3d\n\n";

##
##  PREMIERES LECTURES -> CORRECTIONS 
##

print "INITIALISATION\n\tFirst read of $inputfile\n";

## "}" -> "\n}\n"  &  "{" -> "{\n"  & "$none_separate" -> "$none_separate" &&  "$both_separate" -> "\n$both_separate\n"  &  "$left_separate" -> "\n$left_separate"  &  "$right_separate" -> "$right_separate\n" &  USE reperes
@used_names = ();
@used_section = ();
@brackets = ();
@transforms_lines = ();
@children_lines = ();
@proto_lines = ();

open(COPY, ">".$inputfile."_copy") or die "\nCannot copy file $inputfile\n";
$reg_expr = '[\{\}]';
$copy_lines = 1;
$nb = 1;
$prev_name = "";
$etc = 1;
while (<INPUT>) {
  $nb++;
  ($etc == 8) ? ($etc = 1) : ($etc++);
($NoFirstStep - 1) or print "\tPlease be patient"."\."x$etc."\r";
$NoFirstRead or print READ "BOUCLE INPUT $nb\n";
$NoFirstStep or print "BOUCLE INPUT $nb\n";
  if(/^\s*\#/ || /^\s*$/) { 
    COMMENTS:while(/^\s*\#/ || /^\s*$/) { 
      $_=<INPUT>;
      unless($_) {last COMMENTS;}
      $nb++;
    }
  }  
  local($end_of_line) = $_;
  local($start_of_line) = $_;
$NoFirstRead or print READ "LINE ($nb) = #$_#\n";
$NoFirstStep or print "LINE ($nb) = #$_#\n";
  while(/^(.*)($reg_expr)(.*)$/) {
$NoFirstRead or print READ "BOUCLE REGEXPR $nb\n";
$NoFirstStep or print "BOUCLE REGEXPR $nb\n";
    $start_of_line = $1;
    $expr = $2;
    $end_of_line = $3;

    $_ = $1;
    while(/^(.*)($reg_expr)(.*)$/) {
      $_ = $1;
      $end_of_line = $3.$expr.$end_of_line;
      $expr = $2;
      $start_of_line = $1;
    }

$NoFirstRead or print READ "SOL = #$_#\n";
$NoFirstStep or print "SOL = #$_#\n";

    while(/^(.*)($none_separate|$both_separate|$right_separate|$left_separate)(.*)$/ || /^(.*)\bUSE\s+(\b$name$border)(.*)$/) { 
$NoFirstRead or print READ "BOUCLE SEPARATE ou USE $nb\n";
$NoFirstStep or print "BOUCLE SEPARATE ou USE $nb\n";
      local(@lastn) = ($1,$2,$3);
      $_ = $1;
      while(/^(.*)($none_separate|$both_separate|$right_separate|$left_separate)(.*)$/ || /^(.*)\bUSE\s+(\b$name$border)(.*)$/) {
	$_ = $1;
	$lastn[2] = $3.$lastn[1].$lastn[2];
	$lastn[1] = $2;
	$lastn[0] = $1;
      }

$NoFirstRead or print READ "$_ =? #$lastn[0]# #$lastn[1]# #$lastn[2]#\n";
$NoFirstStep or print "$_ =? #$lastn[0]# #$lastn[1]# #$lastn[2]#\n";
      $_ = $lastn[1];
      if(/$both_separate/) {
	print COPY "$lastn[0]\n$lastn[1]\n";
$NoFirstRead or print READ "BOTH: $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "BOTH: $_ #$lastn[0]# #$lastn[1]#\n";
	$copy_lines += 2;
	if(/\[/) {
	  $_ = $last_node;
	  if(/$section_used/) {
	    push(@used_section,$copy_lines-1);
	  }
	} else {
	  $last_node = $lastn[1];
	}
      } elsif(/$left_separate/) {
	print COPY "$lastn[0]\n$lastn[1]";
$NoFirstRead or print READ "LEFT: $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "LEFT: $_ #$lastn[0]# #$lastn[1]#\n";
	$copy_lines ++;
	$last_node = $lastn[1];
      } elsif(/$right_separate/) {
	print COPY "$lastn[0] $lastn[1]\n";
$NoFirstRead or print READ "RIGHT: $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "RIGHT: $_ #$lastn[0]# #$lastn[1]#\n";
	$copy_lines ++;
	$last_node = $lastn[1];
      } elsif(/$none_separate/) {
	print COPY "$lastn[0] $lastn[1]";
$NoFirstRead or print READ "NONE: $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "NONE: $_ #$lastn[0]# #$lastn[1]#\n";
	$last_node = $lastn[1];
      } else {
	print COPY "$lastn[0] USE $lastn[1]\n";
$NoFirstRead or print READ "USE: $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "USE: $_ #$lastn[0]# #$lastn[1]#\n";
	$copy_lines++;
	$_ = $last_node;
	
	if(/$known_USE_node_call/) {
	  local($yes) = 0;
	  EXIST :for($exist=0;$exist<=$#used_names;$exist++) {
	    if($used_names[$exist] eq $lastn[1]) {
	      $yes = 1;
	      last EXIST;
	    }
	  }
	  unless($yes) {
	    push(@used_names,$lastn[1]);
	  }
	  $last_node = "";
$NoFirstRead or print READ "USE @used_names\n";
$NoFirstStep or print "USE @used_names\n"; 
	}
      }

      $_ = $lastn[1];
      if(/$children_extended/) { 
	push(@children_lines,$copy_lines-1);
$NoFirstRead or print READ "Children @children_lines\n";
$NoFirstStep or print "Children @children_lines\n";
      }
      if(/$transform_extended/) { 
	push(@transforms_lines,$copy_lines);
$NoFirstRead or print READ "Transform @transforms_lines\n";
$NoFirstStep or print "Transform @transforms_lines\n";
      }
      if(/\bPROTO$border/) { 
	$_ = $lastn[2];
$NoFirstRead or print READ "PROTO\n";
$NoFirstStep or print "PROTO\n";
	if(/\bJoint$border|\bSegment$border|\bHumanoid$border/) {
	  $h_anim++;
$NoFirstRead or print READ "HANIM $h_anim\n";
$NoFirstStep or print "HANIM $h_anim\n";
	} else {
	  $proto = 1;
	}
	push(@proto_lines,$copy_lines);
      }
      if(/$virtual_transform/) {
	push(@virtual_transforms_lines,$copy_lines);
      }
      if(/\bInline$border/ || /\bAnchor$border/) {
	$externfiles = 1;
      }
      if(/\burl$border/) {
	$url = 1;
      }
      if(/\bLOD$border/) {
	$lod = 1;
      }

      $_ = $lastn[2];
      $start_of_line = $lastn[2];
    }

    if($expr eq "\{") {
      print COPY "$start_of_line $expr\n";
      $copy_lines++;
      push(@brackets, $copy_lines-1);
$NoFirstRead or print READ "BRACKETS ('{') @brackets\n";
$NoFirstStep or print "BRACKETS ('{') @brackets\n";
    }
    if($expr eq "\}") {
      print COPY "$start_of_line\n$expr\n";
      $copy_lines += 2;
      push(@brackets,-$copy_lines+1);
$NoFirstRead or print READ "BRACKETS ('}')@brackets\n";
$NoFirstStep or print "BRACKETS ('}')@brackets\n";
    }
    $_ = $end_of_line;
  }

  $_ = $end_of_line;
$NoFirstRead or print READ "EOL (2) = #$_#\n";
$NoFirstStep or print "EOL (2) = #$_#\n";

  unless(/^\s*\#/) { 
    while(/^(.*)($none_separate|$both_separate|$right_separate|$left_separate)(.*)$/ || /^(.*)\bUSE\s+(\b$name$border)(.*)$/) { 
$NoFirstRead or print READ "BOUCLE SEPARATE ou USE (2) $nb\n";
$NoFirstStep or print "BOUCLE SEPARATE ou USE (2) $nb\n";

      local(@lastn) = ($1,$2,$3);
      $_ = $1;
      while(/^(.*)($none_separate|$both_separate|$right_separate|$left_separate)(.*)$/ || /^(.*)\bUSE\s+(\b$name$border)(.*)$/) {
	$_ = $1;
$NoFirstStep or print "$_\t";
	$lastn[2] = $3.$lastn[1].$lastn[2];
	$lastn[1] = $2;
	$lastn[0] = $1;
      }

$NoFirstRead or print READ "$_ =? #$lastn[0]# #$lastn[1]# #$lastn[2]#\n";
$NoFirstStep or print "\n$_ =? #$lastn[0]# #$lastn[1]# #$lastn[2]#\n";
      $_ = $lastn[1];
      if(/$both_separate/) {
	print COPY "$lastn[0]\n$lastn[1]\n";
$NoFirstRead or print READ "BOTH (2): $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "BOTH (2): $_ #$lastn[0]# #$lastn[1]#\n";
	$copy_lines += 2;
	if(/\[/) {
	  $_ = $last_node;
	  if(/$section_used/) {
	    push(@used_section,$copy_lines-1);
	  }
	} else {
	  $last_node = $lastn[1];
	}
      } elsif(/$left_separate/) {
	print COPY "$lastn[0]\n$lastn[1]";
	$copy_lines ++;
$NoFirstRead or print READ "LEFT (2): $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "LEFT (2): $_ #$lastn[0]# #$lastn[1]#\n";
	$last_node = $lastn[1];
      } elsif(/$right_separate/) {
	print COPY "$lastn[0] $lastn[1]\n";
	$copy_lines ++;
$NoFirstRead or print READ "RIGHT (2): $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "RIGHT (2): $_ #$lastn[0]# #$lastn[1]#\n";
	$last_node = $lastn[1];
      } elsif(/$none_separate/) {
	print COPY "$lastn[0] $lastn[1]";
$NoFirstRead or print READ "NONE (2): $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "NONE (2): $_ #$lastn[0]# #$lastn[1]#\n";
	$last_node = $lastn[1];
      } else { 
	print COPY "$lastn[0] USE $lastn[1]\n";
$NoFirstRead or print READ "USE (2): $_ #$lastn[0]# #$lastn[1]#\n";
$NoFirstStep or print "USE (2): $_ #$lastn[0]# #$lastn[1]#\n";
	$copy_lines++;
	$_ = $last_node;
	if(/$known_USE_node_call/) {
	  local($yes) = 0;
	  EXIST :for($exist=0;$exist<=$#used_names;$exist++) {
	    if($used_names[$exist] eq $lastn[1]) {
	      $yes = 1;
	      last EXIST;
	    }
	  }
	  unless($yes) {
	    push(@used_names,$lastn[1]);
	  }
	  $last_node = "";
$NoFirstRead or print READ "USE @used_names\n";
$NoFirstStep or print "USE @used_names\n";
	}
      }

      $_ = $lastn[1];
      if(/$children_extended/) {
	push(@children_lines,$copy_lines-1);
$NoFirstRead or print READ "Children @children_lines\n";
$NoFirstStep or print "Children @children_lines\n";  
      }
      if(/$transform_extended/) {
	push(@transforms_lines,$copy_lines);
$NoFirstRead or print READ "Transform @transforms_lines\n";
$NoFirstStep or print "Transform @transforms_lines\n";
      }
      if(/\bPROTO$border/) { 
	$_ = $lastn[2];
$NoFirstRead or print READ "PROTO\n";
$NoFirstStep or print "PROTO\n";
	if(/\bJoint$border|\bSegment$border|\bHumanoid$border/) {
	  $h_anim++;
$NoFirstRead or print READ "HANIM $h_anim\n";
$NoFirstStep or print "HANIM $h_anim\n";
	} else {
	  $proto = 1;
	}
	push(@proto_lines,$copy_lines);
      }
      if(/$virtual_transform/) {
	push(@virtual_transforms_lines,$copy_lines);
      }
      if(/\bInline$border/ || /\bAnchor$border/) {
	$externfiles = 1;
      }
      if(/\burl$border/) {
	$url = 1;
      }
      if(/\bLOD$border/) {
	$lod = 1;
      }

      $_ = $lastn[2];
      $end_of_line = $lastn[2];
    }
  }

  $_ = $end_of_line;
  if(/^(.*)[\r\n]*/) { 
    $_ = $1;
    if(/^(.*)\r/) {
      $_ = $1;
    }
    unless(/^\s*\#/ || /^\s*$/) { 
      print COPY "$_\n";
      $copy_lines++;
    }
$NoFirstRead or print READ "REOL #$end_of_line#\n";
$NoFirstStep or print "REOL #$end_of_line#\n";
  }
}
close(COPY);
close(INPUT);

if($h_anim) {
  $children_extended = "\\bchildren$border";
  $transform_extended = "\\bTransform$border";
  $group_extended = "\\bGroup$border";
}

while($proto || $lod || ($externfiles && $url))   {
    print "\n\n## WARNING ##\n$inputfile ";
    if($proto || $lod) {
      print "uses ";
      if($proto) {
	print "unknown PROTOTYPES\n";
	$proto = 0;
      } else {
	print "various levels of detail (LOD node)\n";
	$lod = 0;
      }
    } else {
      print "references EXTERN FILES (Inline or Anchor node)\n";
      $externfiles = 0;
    }
    print "The conversion will probably fail\n";
    print "Do you want to try it anyway ? (y or n): ";
    $_ = <STDIN>;
    ANSWER: while(/./) { 
	if(/^[yY]$/) { 
	  print "\nAs you like...\n";
	  last ANSWER;
	} elsif(/^[nN]$/) {
	  &mydie("\nTry another file...\n\n");
	} else {
	  print "\nAnswer not understood\nDo you want to try it anyway ? (y or n): ";
	  $_ = <STDIN>;
	}
      }
}

unless($h_anim) {
  print "\n\nH-ANIM standard used in $inputfile\n";
  if($filetype eq 'o') {
    print "ROBOT mode (-r) forced !\n";
    $filetype = 'r';
  }
}

if($filetype eq 'r') {
  print "\nPlease choose between the kinematic options below (free-flying anyway):\n";
  print "\t1: A rotoide joint (yaw) per body\n";
  print "\t3: A spherical joint (roll-pitch-yaw) ";
  ($h_anim) ? print "per body\n" : print "before each H-Anim joint\n";
  print "Your choice ? (1 or 3):\t";
  $_ = <STDIN>;
  ANSWER: while(/./) { 
      if(/^([13])$/) { 
	$no_spherical = ($1-1) ? 0 : 1;
	last ANSWER;
      } else {
	print "\nAnswer not understood\n";
	print "\t1: A rotoide joint (yaw) per body\n";
	print "\t3: A spherical joint (roll-pitch-yaw)";
	($h_anim) ? print "per body\n" : print "before each H-Anim joint\n";
	print "Your choice ? (1 or 3):\t";
	$_ = <STDIN>;
      }
    }
# Creation d'au moins un obstacle dans le cas d'un robot
  print OUTPUT "p3d_beg_desc P3D_ENV $env_name\n\n";
  print OUTPUT "  p3d_beg_desc P3D_OBSTACLE $env_name-sol\n";
  print OUTPUT "   p3d_add_desc_box sol 100 100 10.0\n";
  print OUTPUT "   p3d_set_prim_pos sol 0.0 0.0 -100 0.0 0.0 0.0\n";
  print OUTPUT "  p3d_end_desc\n";
  print OUTPUT "  p3d_set_obst_color $env_name-sol Grey\n\n\n";
  $compteur += 6;
} else {
# Creation d'au moins un robot dans le cas d'un obstacle
  print OUTPUT "p3d_beg_desc P3D_ENV $env_name\n\n";
  print OUTPUT "  p3d_beg_desc P3D_ROBOT pipo\n";
  print OUTPUT "    p3d_beg_desc P3D_BODY pipo.body\n";
  print OUTPUT "#      p3d_add_desc_box box 0 0 0\n";
  print OUTPUT "#      p3d_set_prim_pos box $max $max $max  0.0 0.0 0.0\n";
  print OUTPUT "    p3d_end_desc\n";
  print OUTPUT "  p3d_end_desc\n\n";
  $compteur += 7;
}

# SUPPRESSION DE LIGNES & CONSEQUENCES
sub cut_those {
  local(@list) = @_;
  local($leave_brackets) = $list[$#list];
  for($i=0;$i<$#list;$i++) {
    $NoFirstReadProto or print "LINE ($i) = $list[$i]\n";
    local($j) = 0;
    local(@bracket_splice) = ();
    local(@beg_end_cut) = ();
    while(($j <= $#brackets) && (abs($brackets[$j])<$list[$i]))  {
      $j++;
    }
$NoFirstReadProto or print "$brackets[$j] <? $list[$i] (j=$j)\n";
    ($leave_brackets) or push(@bracket_splice,$j);
    ($leave_brackets) ? push(@beg_end_cut,abs($brackets[$j])+1) : push(@beg_end_cut,$list[$i]);
    $j++;
    if($j <= $#brackets) { 
      local($indef) = 1;
      local($exposedField) = $leave_brackets-1;
      while(($j <= $#brackets) && ($indef || $exposedField)) {
	$indef += (($brackets[$j]) <=> 0);
$NoFirstReadProto or print "$brackets[$j] => indef = $indef\n";
	if($indef || $exposedField) { 
	  push(@bracket_splice,$j);
	  if($indef==2) { $exposedField = 0; }
	} else {
	  ($leave_brackets) or push(@bracket_splice,$j);
	}
	$j++;
      }
      ($leave_brackets) ? push(@beg_end_cut,abs($brackets[$j-1])-1) : push(@beg_end_cut,abs($brackets[$j-1]));
      unless($indef) { 
	local($x) = 0;
	local($y) = 0;
	for($k=$beg_end_cut[0];$k<=$beg_end_cut[1];$k++) {
	  push(@cut,$k);
	  while(($x<=$#transforms_lines) && ($transforms_lines[$x]<$k)) { $x++; }
	  if($transforms_lines[$x]==$k)  {splice(@transforms_lines,$x,1); }
	  while(($y<=$#children_lines) && ($children_lines[$y]<$k)) { $y++; }
	  if($children_lines[$y]==$k) { splice(@children_lines,$y,1); }
	}
	push(@cutted_section,$beg_end_cut[0]);
	push(@cutted_section,$beg_end_cut[1]);

	for($k=0;$k<=$#bracket_splice;$k++) {
$NoFirstReadProto or print "TO BE SPLICE: $brackets[$bracket_splice[$k]-$k]\n";
          splice(@brackets,$bracket_splice[$k]-$k,1);
        }
$NoFirstReadProto or print "bracket_splice = @bracket_splice\n";
      }
    }
  }
$NoFirstReadProto or print "CUTTED SECTION: @cutted_section\n";
$NoFirstReadProto or print "BRACKETS: @brackets\n";
}

# REPERER LES LIGNES DE DEFINITION DES PROTOTYPES && DES TRANSFORMATIONS VIRTUELLES (Noeuds avec champ Center|Translation|...)(CSQ SUR LES LIGNES DES CHILDREN ET TRANSFORMS)
$NoFirstReadProto or print "\nDelete PROTO...\n";
$NoFirstReadProto or print "BRACKETS: #@brackets#\n";
$NoFirstReadProto or print "PROTOLINES: #@proto_lines#\n";
$NoFirstReadProto or print "VIRTUALTRANSFORMLINES: #@virtual_transforms_lines#\n";
$NoFirstReadProto or print "transforms_lines = #@transforms_lines#\n";
$NoFirstReadProto or print "children_lines = #@children_lines#\n";
@cut = ();
@cutted_section = ();
&cut_those(@proto_lines,0);
&cut_those(@virtual_transforms_lines,1);


## CAPTURE DES LINEARISATIONS UTILES
print "\n\tCapture of needed linearisation\n";

# GARDER LES CHILDREN DE TRANSFORMS UNIQUEMENT
$NoFirstRead or print READ "\nchildren utils...\n";
@children_transform_lines = ();
$j=0;
$NoFirstRead or print READ "transforms_lines ($#transforms_lines) = #@transforms_lines#\n";
$NoFirstRead or print READ "\nchildren_lines ($#children_lines) = #@children_lines#\n";
for($i=0;$i<=$#transforms_lines;$i++) {
  while(($j <= $#children_lines) && ($children_lines[$j]<$transforms_lines[$i]))  {
    $j++;
  }
  if($j <= $#children_lines) { 
    $children_transform_lines[$i]=$children_lines[$j];
$NoFirstRead or print READ "children utils (push ($children_lines[$j-1]<?$transforms_lines[$i]<?$children_lines[$j])) : @children_transform_lines\n";
  }
  $j++;
}
$NoFirstRead or print READ "\nchildren utils : @children_transform_lines\n\n";
$NoFirstReadProto or print "transforms_lines ($#transforms_lines): #@transforms_lines#\n";
$NoFirstReadProto or print "children_lines ($#children_lines): @children_lines\n";
$NoFirstReadProto or print "children utils ($#children_transform_lines): #@children_transform_lines#\n";

## CAPTURE DES TRANSFORMS INVERSES
@like_open_children = ();
@invalid_transforms = ([]);
$total_lines = 0;
open(COPY,$inputfile."_copy") or die "\nCannot open copy of file $inputfile\n";
$copy_lines = 0;
$next_bracket_index = 0;
$etc = 1;
$cut_index = 0; 
$NoFirstRead or print READ "cut = @cut\n";
$NoFirstRead or print READ "\nbrackets (childrenTransform->invTransform) @brackets\n";
$cutted_section_lenght = ($#cutted_section+1)/2;
INVERSETRANS: while (<COPY>) {
  $copy_lines++;
  $total_lines++;
  ($etc == 8) ? ($etc = 1) : ($etc++);
  print "\tPlease be patient"."\."x$etc."\r";

  local($next_line) = 0;
  LOCALIZED: for($i=0;$i<$cutted_section_lenght;$i++) {
      if(($copy_lines >= $cutted_section[2*$i]) && ($copy_lines <= $cutted_section[2*$i+1])) {
        $next_line = 1;
	last LOCALIZED;
      }
    }

  if($next_line) {  next INVERSETRANS; }

$NoFirstRead or print READ "$copy_lines\n";
  if($copy_lines > abs($brackets[$next_bracket_index])) { $next_bracket_index++; }

  if(/^\s*\#/) {
    push(@cutted_section,$copy_lines);
    COMMENTS:while(/^\s*\#/) {
      push(@cut,$copy_lines);
$NoFirstRead or print READ "EMPTY(cut $copy_lines) @cut\n";
      $_ = <COPY>;
      $copy_lines++;
      unless($_) {last COMMENTS;}
    }
    push(@cutted_section,$copy_lines-1);
  }

  if(/\[/) {
    push(@like_open_children,$copy_lines);
$NoFirstRead or print READ "TRANS(like_open $copy_lines) @like_open_children\n";
  }

  if(/\]/) {
    local($loc_tested) = $like_open_children[$#like_open_children];
    local($used) = 0;
    TESTUSE: for($i=0;$i<=$#used_section;$i++) {
	if($used_section[$i]>=$loc_tested) {
	  $used = ($used_section[$i]==$loc_tested) ? 1 : 0;
	  last TESTUSE;
	}
      }
    unless($used) {
      for($i=$loc_tested;$i<=$copy_lines;$i++) {
	local($cut_it) = 1;
	CUTTED: for($j=0;$j<($#cutted_section+1)/2;$j++) {
	    if(($i >= $cutted_section[2*$j]) && ($i <= $cutted_section[2*$j+1])) {
	      $cut_it = 0;
	      last CUTTED;
	    }
	  }
	if($cut_it) { push(@cut,$i); }
      }
$NoFirstRead or print READ "TRANS(like_close cut) $i\n";
      pop(@like_open_children);
$NoFirstRead or print READ "TRANS(like_close $copy_lines) @cut\n";
    }
  }

  if(/\bcenter$border/ || /\brotation$border/ || /\bscale$border/ || /\bscaleOrientation$border/ || /\btranslation$border/) {
    $index_transform = 0;
    while(($index_transform <= $#transforms_lines) && ($transforms_lines[$index_transform] < $copy_lines)) { 
      $index_transform++;
    }    
$NoFirstRead or print READ "TRANS(index $copy_lines) $index_transform $transforms_lines[$index_transform-1] $children_transform_lines[$index_transform-1]\n";
    if($children_transform_lines[$index_transform-1] < $copy_lines) {
      local($index) = $#invalid_transforms+1;
      push(@paste_at,$index);
      local($tested_line) = 1;
      local($trans_bracket) = $next_bracket_index;
      while($tested_line) {
	($brackets[$trans_bracket]<0) ? ($tested_line--) : ($tested_line++); 
	$trans_bracket++;
      }
      $tested_line = -1;
      $trans_bracket -= 2;
      while($tested_line) {
	($brackets[$trans_bracket]>0) ? ($tested_line++) : ($tested_line--); 
	$trans_bracket--;
      }
      push(@paste_at,$brackets[$trans_bracket+1]+1);   
$NoFirstRead or print READ "TRANS(paste $copy_lines) @paste_at\n";
$NoFirstRead or print READ "TRANS(paste $copy_lines) $index\n";
      $invalid_transforms[$index] = [(0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0)];
$NoFirstRead or print READ "$_\n";
      while(/\bcenter$border/ || /\brotation$border/ || /\bscale$border/ || /\bscaleOrientation$border/ || /\btranslation$border/ || /^\s*$/) {
$NoFirstRead or print READ "TRANS(C-R-S-SO-T) $copy_lines\n";
	if(/\s*\bcenter$border\s+($number)\s+($number)\s+($number)/) {
	  $invalid_transforms[$index][0]=$1;
	  $invalid_transforms[$index][1]=$2;
	  $invalid_transforms[$index][2]=$3;
$NoFirstRead or print READ "TRANS(center) $copy_lines\n";
	} elsif(/\s*\brotation$border\s+($number)\s+($number)\s+($number)\s+($number)/) { 
	  $invalid_transforms[$index][3]=$1;
	  $invalid_transforms[$index][4]=$2;
	  $invalid_transforms[$index][5]=$3;
	  $invalid_transforms[$index][6]=$4;
$NoFirstRead or print READ "TRANS(rotation) $copy_lines\n";
	} elsif(/\s*\bscale$border\s+($number)\s+($number)\s+($number)/) { 
	  $invalid_transforms[$index][7]=$1;
	  $invalid_transforms[$index][8]=$2;
	  $invalid_transforms[$index][9]=$3;
$NoFirstRead or print READ "TRANS(scale) $copy_lines \n";
	} elsif(/\s*\bscaleOrientation$border\s+($number)\s+($number)\s+($number)\s+($number)/) { 
	  $invalid_transforms[$index][10]=$1;
	  $invalid_transforms[$index][11]=$2;
	  $invalid_transforms[$index][12]=$3;
	  $invalid_transforms[$index][13]=$4;
$NoFirstRead or print READ "TRANS(scaleOrientation) $copy_lines\n";
        } elsif(/\s*\btranslation$border\s+($number)\s+($number)\s+($number)/) { 
	  $invalid_transforms[$index][14]=$1;
	  $invalid_transforms[$index][15]=$2;
	  $invalid_transforms[$index][16]=$3;
$NoFirstRead or print READ "TRANS(translation) $copy_lines\n";
	}
	push(@cut,$copy_lines);
	$NoFirstRead or print READ "TRANS(cut $copy_lines) @cut\n";
	$_ = <COPY>;
	$copy_lines++;
        $total_lines++;
      }
    } 
#else {
#      while(/\bcenter$border/ || /\brotation$border/ || /\bscale$border/ || /\bscaleOrientation$border/ || /\btranslation$border/ || /^\s*$/) {
#	$NoFirstRead or print READ "TRANS(1 C-R-S-SO-T) $copy_lines ligne precedente deja teste\n";
#	$_ = <COPY>;
#	$copy_lines++;
#        $total_lines++;
#      }
#    }
  }
}
while(@used_section) { pop(@used_section); }
while(@cutted_section) { pop(@cutted_section); }
while(@transforms_lines) { pop(@transforms_lines); }
while(@children_transform_lines) { pop(@children_transform_lines); }
close(COPY);
$NoFirstRead or print READ "\nbrackets (invTransform->invChildren) @brackets\n";

# LISTER LES CHILDREN INVALIDE
@invalid_children = ();
sub byline { $a <=> $b; }
@cut_sort = sort byline @cut;
while(@cut) { pop(@cut); }

$NoFirstRead or print READ "CHILD... $j  (BRACK) @brackets\n";
$j=0;
#$k=0; 
for($i=0;$i<=$#children_lines;$i++) {
$NoFirstRead or print READ "CHILD... $i  $#children_lines\n";
$NoFirstRead or print READ "CHILD... $i  @like_open_children\n";
$NoFirstRead or print READ "CHILD... $i  @children_lines\n";
  while(($j <= $#like_open_children) && ($like_open_children[$j] < $children_lines[$i]))  {
    $j++;
  }
#  while(($k <= $#cut_sort) && ($cut_sort[$k] < $children_lines[$i]))  {
#    $k++; 
#  }
  if($j <= ($#like_open_children+1)) {
$NoFirstRead or print READ "CHILD... $j  (LIKE) $like_open_children[$j]\n";
$NoFirstRead or print READ "CHILD... $i  (CHILD) $children_lines[$i]\n";
    local($offset) = 2; #1;
#    if(($k <= $#cut_sort) && ($cut_sort[k]==($children_lines[$i]+1))) {
#      $offset++;
#      $k++;
#      while(($k <= $#cut_sort) && ($cut_sort[$k]==($cut_sort[k-1]+1))) {
#	$k++;
#	$offset++;
#      }
#    }	
    if(($j > $#like_open_children) || ($like_open_children[$j]-$children_lines[$i] > $offset)) {
      push(@invalid_children,$children_lines[$i]+1);
$NoFirstRead or print READ "CHILD... $i  (INVAL) @invalid_children\n";     
      local($count) = 1;
      local($next) = 0;
      while($children_lines[$i] > abs($brackets[$next])) {
	$next++;
      }
$NoFirstRead or print READ "CHILD... $i  (INVAL...) $brackets[$next-1] $children_lines[$i]  $brackets[$next]\n";
      while($next) {
	($brackets[$next] > 0) ? ($count++) : ($count--);
	if($count) {
	  $next++;
	} else {
	  push(@invalid_children,$brackets[$next]);
$NoFirstRead or print READ "CHILD... $i  (INVAL 2) @invalid_children\n";
	  $next = 0;
	}
      }
    }
  }
$NoFirstRead or print READ "CHILD $i... @invalid_children\n";
}
while(@children_lines) { pop(@children_lines); }
$NoFirstRead or print READ "\nbrackets (invChildren->corrections) @brackets\n";


## REECRITURE DES TRANSFORMS A L'ENDROIT & DES CHILDREN INVALIDES & EFFACEMENT DES LIGNES DU @CUT_SORT
if(@invalid_transforms || @invalid_children || @cut_sort) {

print "\n\tLinearisation\n";

  sub byabs { abs($a) <=> abs($b); }
  local(@invalid_children_sort) = sort byabs @invalid_children;    
  while(@invalid_children) { pop(@invalid_children); }

  $total_lines = 0;
  open(COPYW,">".$inputfile."_copy1") or die "\nCannot create copyw of file $inputfile\n";
  open(COPYR,$inputfile."_copy") or die "\nCannot open copy of file $inputfile\n";
  local($copy_lines) = 0;
  local($cut_index) = 0;
  local($paste_end) = ($#paste_at+1)/2;
  $etc = 1;
  local(@new_brackets) = ();
  for($i=0;$i<=$#brackets;$i++) { push(@new_brackets,$brackets[$i]); }
  while (<COPYR>) {
    $copy_lines++;
    ($etc == 8) ? ($etc = 1) : ($etc++);
    print "\tPlease be patient"."\."x$etc."\r";

    while($copy_lines == $cut_sort[$cut_index]) { 
      $cut_index++;
      print COPYW "#$_";
$NoFirstRead or print READ "CUTTED... $copy_lines\n";
      $_ = <COPYR>;
      $copy_lines++;
    }

    if(@invalid_children_sort) {
      if($copy_lines == abs($invalid_children_sort[0])) {
$NoFirstRead or print READ "INVALID... $copy_lines\n";
        if($invalid_children_sort[0]>0) {
	  print COPYW "[\n";
	  $total_lines++;
$NoFirstRead or print READ "INVALID [ $copy_lines\n";
	} elsif($invalid_children_sort[0]<0) {
	  print COPYW "]\n";	
	  $total_lines++;
$NoFirstRead or print READ "INVALID ] $copy_lines\n";
	}
        for($i=0;$i<=$#brackets;$i++) {
	  if((abs($brackets[$i])) >= $copy_lines) {
	    ($new_brackets[$i]) += (($new_brackets[$i]) <=> 0);
	  }
	}
        shift(@invalid_children_sort);
$NoFirstRead or print READ "INVALID... @invalid_children_sort\n";
      }
    }
    
    if(@invalid_transforms) {
      PASTE: for($paste=0;$paste<$paste_end;$paste++) {
	  if($copy_lines == $paste_at[2*$paste+1]) {
	    local($index) = $paste_at[2*$paste];
$NoFirstRead or print READ "\nINDEX = $index\t$copy_lines\n";
	    print COPYW "center $invalid_transforms[$index][0] $invalid_transforms[$index][1] $invalid_transforms[$index][2]\n";
	    print COPYW "rotation $invalid_transforms[$index][3] $invalid_transforms[$index][4] $invalid_transforms[$index][5] $invalid_transforms[$index][6]\n";
	    print COPYW "scale $invalid_transforms[$index][7] $invalid_transforms[$index][8] $invalid_transforms[$index][9]\n";
	    print COPYW "scaleOrientation $invalid_transforms[$index][10] $invalid_transforms[$index][11] $invalid_transforms[$index][12] $invalid_transforms[$index][13]\n";
	    print COPYW "translation $invalid_transforms[$index][14] $invalid_transforms[$index][15] $invalid_transforms[$index][16]\n";
	    $total_lines += 5;
	    for($i=0;$i<=$#brackets;$i++) {
	      if((abs($brackets[$i])) > $copy_lines) {
		($new_brackets[$i]) += (($new_brackets[$i]) <=> 0)*5;
	      }
	    }
	    last PASTE;
	  }
      }
    }
    print COPYW "$_";
    $total_lines++;
  }
  
  while(@brackets) { pop(@brackets); }
  for($i=0;$i<=$#new_brackets;$i++) { push(@brackets,$new_brackets[$i]); }
  while(@new_brackets) { pop(@new_brackets); }

  while(@invalid_transforms) { pop(@invalid_transforms); }
  while(@invalid_children_sort) { pop(@invalid_children_sort); }
  while(@cut_sort) { pop(@cut_sort); }
  while(@paste_at) { pop(@paste_at); }
  close(COPYR);
  close(COPYW);
}
$NoFirstRead or print READ "\nbrackets (corrections->useCapture) @brackets\n";


## CAPTURE DES "DEF" DES "USE" ET RECRITURE DES "USE" (DEF TRAITES UN PAR UN)
$nb_copy = 1;
$nb_max = @used_names+1;
unless(@used_names) { 
  rename($inputfile."_copy$nb_copy",$inputfile."_copyf") or die "\nCannot rename file $inputfile_copy1 to $inputfile_copyf";
}
$times = 0;
while(@used_names && ($nb_copy<$nb_max)) {
  local($times) = $nb_max - $nb_copy;
  ($nb_copy-1) or print "\t$times nodes USE will be copied\n";
  ($nb_copy<2) or print "\t$times nodes USE to process\n";
  local($def_to_do) = 1;
  local($def_name_done) = "";
  local(@to_splice) = ();
  if($nb_copy>1) {
    local($nb_copy_prev) = $nb_copy-1;
    unlink($inputfile."_copy$nb_copy_prev");
  }
  open(COPYR,$inputfile."_copy$nb_copy") or die "\nCannot open copy$nb_copy of file $inputfile\n";
  $nb_copy++;
  local($copy_file_name) = $inputfile."_copy$nb_copy";
  if($nb_copy == $nb_max) { $copy_file_name = $inputfile."_copyf"; }
  open(COPYW,">".$copy_file_name) or die "\nCannot create $copy_file_name\n";
$NoFirstRead2 or print READ "COPY $nb_copy EN COURS\n";
  local($copy_lines) = 0;
  $total_lines = 0;
  local($next_bracket_index) = 0;
  local($etc) = 1;
  local(@new_brackets) = ();
  for($i=0;$i<=$#brackets;$i++) { push(@new_brackets,$brackets[$i]); }

  while (<COPYR>) {
    $special_line = 0;
    $copy_lines++;
    ($etc == 8) ? ($etc = 1) : ($etc++);
    print "\tPlease be patient"."\."x$etc."\r";
    
    if(/^\s*\#/) {
      while(/^\s*\#/) {
	print COPYW "$_";
	$total_lines++;
$NoFirstRead2 or print READ "Commentaire de PROTO ($copy_lines)\n";
	$_=<COPYR>;
	$copy_lines++;
      }
    }

    if($def_to_do && ($copy_lines > abs($brackets[$next_bracket_index]))) { $next_bracket_index++; }

    if($def_to_do && /^(.*)DEF\s+\b($name)$border(.*)[\n\r]/) {
$NoFirstRead2 or print READ "\nMATCH ? #$2#\n";
      local($is_used) = 0; 
      MATCH: for($i=0;$i<=$#used_names;$i++) {
	  if($2 eq $used_names[$i]) {
	    $is_used = $i+1;
	    $def_name_done = $used_names[$i]; 
	    $def_to_do = 0;
$NoFirstRead2 or print READ "(1) @used_names\n";
	    splice(@used_names,$i,1);
$NoFirstRead2 or print READ "(2) @used_names\n";
	    last MATCH;
	  }
	}
      if($is_used) {
$NoFirstRead2 or print READ "IS USED\n";
	open(USETEMP,">"."$def_name_done.use_copy") or die "\nCannot create file $used_names[$is_used-1].use_copy\n";
	local($next) = $next_bracket_index+1;
	local($count) = 1;
	local($begin_use) = 0;
	local($end_use) = 0;
	while($next) {
	  (@brackets[$next] > 0) ? ($count++) : ($count--);
	  if($count) {
	    $next++;
	  } else {
	    $begin_use = $brackets[$next_bracket_index];
	    $end_use = -$brackets[$next];
	    $next = 0;
	  }
	}
$NoFirstRead2 or print READ "COPY: $begin_use ->  $end_use\n";
	print COPYW "$1 DEF $2$3\n";
        $total_lines++;
        local($temp_count) = 0;
	print USETEMP " $3\n";
        $_ = $3;
        if(/\{/) {
	  push(@to_splice, $temp_count);
	} elsif(/\}/) {
	  push(@to_splice,-$temp_count);
	}
	for($usew=($begin_use+1);$usew<=$end_use;$usew++) {
	  $_ = <COPYR>;
	  $copy_lines++;
	  print COPYW "$_";
	  $total_lines++;
	  if(/^(.*)DEF\s+\b($name)$border(.*)$/) { $_="$1 $3"; }
	  print USETEMP "$_";	  
	  $temp_count++;
	  unless(/^\s*\#/) {
	    if(/\{/) {
	      push(@to_splice, $temp_count);
	    } elsif(/\}/) {
	      push(@to_splice,-$temp_count);
	    }
	  }
	}
	close(USETEMP);
	$special_line = 1;
      }
    }

    if(($def_to_do-1) && /^(.*)USE\s+\b($name)$border(.*)[\n\r]/) {
$NoFirstRead2 or print READ "\nUSE...\n";
      if($2 eq $def_name_done) {
$NoFirstRead2 or print READ "YES ! $2\n";
	open(USETEMP,"$2.use_copy") or die "\nCannot open temp file $2.use_copy\n";
	local($count_lines) = 0;
	print COPYW "$1";       
	while(<USETEMP>) {
	  print COPYW "$_";
	  $total_lines++;
	  $count_lines++;
$NoFirstRead2 or print READ "($count_lines) #$_#";
	}
#	$_ = "$3\n";
        $count_lines--;
        local($total_prev) = $total_lines-$count_lines;
        local($to_splice_index) = 0;
$NoFirstRead2 or print READ "| $total_prev --->\n";
        local($i) = 0;
        while(($i<=$#new_brackets) && ((abs($new_brackets[$i])) < $total_prev)) {
	  $i++;
$NoFirstRead2 or print READ "abs($new_brackets[$i]) < $total_prev+$times*$count_lines => ";
	  $to_splice_index = $i;
	}
        for($j=$i;$j<=$#new_brackets;$j++) {
	  ($new_brackets[$j]) += ($new_brackets[$j] <=> 0)*$count_lines;
	}
$NoFirstRead2 or print READ "\nTOSPLICE (@to_splice)\n";
        for($s=0;$s<=$#to_splice;$s++) {
	  local($sign) = ($to_splice[$s]<=>0);
	  unless($sign) { $sign = 1; }
	  splice(@new_brackets,$to_splice_index+$s,0,$to_splice[$s]+$sign*$total_prev);
$NoFirstRead2 or print READ "($to_splice_index+$s) @new_brackets\n";
	}
        $times++;
	close(USETEMP);
	$special_line = 1;
      }
    }

    unless($special_line) {
$NoFirstRead2 or print READ ".";
      print COPYW "$_";
      $total_lines++;
      $special_line = 0;
    }
  }

  while(@brackets) { pop(@brackets); }
  for($i=0;$i<=$#new_brackets;$i++) { push(@brackets,$new_brackets[$i]); }
  while(@new_brackets) { pop(@new_brackets); }
  close(COPYR);
  close(COPYW);
}
$NoFirstRead or print READ "\nbrackets (useCapture->empty) @brackets\n";

print "\n\tDeleting empty lines\n";

## EFFACER TOUTES LES LIGNES VIDES, TOUS LES FICHIERS TEMPORAIRES ET OUVRIR LA COPIE VRML
open(COPYF,$inputfile."_copyf") or die "\nCannot open copy $inputfile_copyf\n";
open(FINAL,">".$inputfile."_final") or die "\nCannot create file $inputfile_final\n";
$total_lines = 0;
$empty = 0;
while(<COPYF>) {
  if(/^\s*\#/ || /^\s*$/) {
    COMMENTS:while(/^\s*\#/ || /^\s*$/) {
      $_=<COPYF>;
      unless($_) {last COMMENTS;}
      $empty++;
      $NoConsole or print "$empty lignes vides\r";
    }
  }
  
  if(/^\s*(.+)$/) {
    print FINAL "$1\n";
    $total_lines++;
  }
}
close(COPYF);
close(FINAL);
close(READ);
print "INITIALISATION COMPLETED\n\n";
$keeplink or unlink(<*.*_copy*>);
open(INPUT,$inputfile."_final") or die "\nCannot open file $inputfile\n";


##
##  LECTURE & TRADUCTION
##
$inputnb = 0;

while (<INPUT>) {
#DEBUG
$inputnb++;
$NoConsoleHeader or print "MAIN: ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");

  if(/^\s*\#/ || /^\s*$/) {
    COMMENTS:while(/^\s*\#/ || /^\s*$/) {
      $_=<INPUT>;
      unless($_) {last COMMENTS;}
      $inputnb++;
      $NoConsole or print "line $inputnb read\t$faces faces\n";
      $percent = int(1000*$inputnb/$total_lines)/10;
      $NoPercent or print "$percent % of $inputfile read      \r";
      ($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
    }
  }

  if(/$group_extended/ || /\bCollision$border/ || /\bBillboard$border/ || /\bAnchor$border/) {
    $stop_no_use_chidren = 0;

    do {
      if(/^\s*\#/ || /^\s*$/) {
	COMMENTS:while(/^\s*\#/ || /^\s*$/) {
	  $_=<INPUT>;
	  unless($_) {last COMMENTS;}
	  $inputnb++;
	  $NoConsole or print "line $inputnb read\t$faces faces\n";
	  $percent = int(1000*$inputnb/$total_lines)/10;
	  $NoPercent or print "$percent % of $inputfile read      \r";
	  ($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
	}
      }

      unless($h_anim) {
	if(/\bSegment$border/) {
	  $nb_body++;
	  push(@body_hierarchy,$hierarchy);
	  push(@body_hierarchy,"body$nb_body");
	  push(@body_names,"body$nb_body");
	  push(@previous_names,"body$nb_body");
	  push(@body_nb_poly,0);
	}
	if(/^\s*\bname$border\s+\"($name)\"/) {
	  pop(@body_hierarchy);
	  push(@body_hierarchy,$1);
	  pop(@body_names);
	  push(@body_names,$1);
	  pop(@previous_names);
	  push(@previous_names,$1);
	}
      }

      if(/$children_extended/) {
        push(@no_use_close_children,$hierarchy);
#DEBUG
$afficheNone or print BUG "children INUTILE\t$inputnb\npush: [@no_use_close_children]\n";
      }

      if(/$open_children/ || /$close_bracket/) {
        $stop_no_use_chidren = 1;
#DEBUG
$afficheNone or print BUG "[ du children INUTILE | pas de children\t$inputnb\n";
      }

      unless($stop_no_use_chidren) {
        $_ = <INPUT>;
#DEBUG
$inputnb++;
$NoConsoleHeader or print "CHILDREN (MAIN): ";
$NoConsole or print "line $inputnb read\t$faces faces\n";
$percent = int(1000*$inputnb/$total_lines)/10;
$NoPercent or print "$percent % of $inputfile read      \r";
($percent <= 100) or &mydie("\n\n## ERROR ##\n\tConversion impossible\n\tPlease verify the validity of $inputfile\n");
      }
    } until($stop_no_use_chidren);
  }
 
  if(/\s*(DEF)?\s*($name)?\s*$transform_extended/) {
 #DEBUG
$afficheNone or print BUG "Transform $inputnb\n";
    if($h_anim) {
      &beg_desc_P3D($1,$2,$add_jnt);
      $_ = &transform_sub(0);
    } else {
      if(/\bHumanoid$border/) {
	unless($humanoid_definition) {
	  &beg_desc_P3D(0,0,0);
	  $_ = &transform_sub(0);
	  $humanoid_definition = 1;
	}
      } elsif(/\bJoint$border/) {
	unless($humanoid_definition) {
	  $humanoid_definition = 1;
	  &beg_desc_P3D(0,0,0);
	}
	@jnt_po = (0,0,0);
	@jnt_rot = (0,0,1,0);
	$add_jnt = 1;
	if(($hierarchy == 0) || ($body_hierarchy[$#body_hierarchy-1] != $hierarchy))  { 
	  $add_pipo = 1;
	  push(@body_hierarchy,$hierarchy);
	  push(@body_hierarchy,"pipo_added");
	  $add_jnt = 0;
	}
	$jnt_hierarchy++;
	push(@jnts_hierarchy,$hierarchy);
	local($temp_line) = &transform_sub(1);
	&by_mat_sub("joint",0);
	&beg_desc_P3D($1,$2,$add_jnt);
	$_ = $temp_line;
      } else {
	($filetype ne 'o') or &beg_desc_P3D($1,$2,0);
	$_ = &transform_sub(0);
      }
    }
  }

  if(/\s*(DEF)?\s*($name)?\s*\bShape$border/) {
#DEBUG
$afficheNone or print BUG "shape $inputnb\n";
    local($case) = ($filetype eq 'r') ? 0 : $hierarchy;
    local($temp_line) = "$_";
    unless($case) { &beg_desc_P3D($1,$2,$add_jnt); }
    $_ = $temp_line;
    $_ = &shape_sub;
  }
 
  if(/$close_children/) { 
    $use_full = 1;
    USELESS: for($i=$#no_use_close_children;$i>=0;$i--) {
      if($hierarchy == $no_use_close_children[$i]) {
        $use_full = 0;
	splice(@no_use_close_children,$i,1);
        last USELESS;
      }
    }
    if($use_full) {
      &printbug($afficheTrans,"TRANSFORMS (avant pop)",@transforms);
      $hierarchy--;
$NoShapeHierarchy or print "$last_name  $hierarchy (--)($inputnb)\n";
      unless($h_anim) {
	unless($hierarchy) { 
	  $filetype = 'o';
	}
	if(@jnts_hierarchy && ($hierarchy == $jnts_hierarchy[$#jnts_hierarchy])) {
	  pop(@jnts_hierarchy);
	  if($body_hierarchy[$#body_hierarchy-1] == ($hierarchy+1)) {
	    pop(@body_hierarchy);
	    pop(@body_hierarchy);
	  }
	  $jnt_hierarchy--;
	}
      }
      for($i=0;$i<4;$i++) {pop(@transforms);}
      pop(@previous_names);
      pop(@hierarchy_inversions);
      while(@center) { pop(@center); };
      while(@center_inv) { pop(@center_inv); };
      while(@rotation) { pop(@rotation); };
      while(@scale) { pop(@scale); };
      while(@scaleOrientation) { pop(@scaleOrientation); };
      while(@scaleOrientation_inv) { pop(@scaleOrientation_inv); };
      while(@translation) { pop(@translation); };
#DEBUG
$NoNormal or print BUG "\nhierarchy_inversions(pop) = @hierarchy_inversions\t$inputnb\n\n";

      &printbug($afficheTrans,"TRANSFORMS (apres pop)",@transforms);

$afficheNone or print BUG "main:\thierarchy-- = $hierarchy  \t$1\t$inputnb\n";
    }
  }
}

print MACRO "  p3d_end_desc\n\n";
$compteur++;

## AFFECTER LES COULEURS AUX OBJETS
(($humanoid_definition-1) && ($filetype ne 'r')) or print MACRO "p3d_end_desc\n\n";
(($humanoid_definition-1) && ($filetype ne 'r')) or $compteur++;
($humanoid_definition-1) or ($poly_ref = 0);
($humanoid_definition-1) or ($poly_index = 0);


@splice_index = ();
for($i=0;$i<=$#body_nb_poly;$i++) {
  unless($body_nb_poly[$i]) {
    push(@splice_index,$i);
  }
}

for($i=0;$i<=$#splice_index;$i++) {
  local($index) = $splice_index[$i]-$i;
  splice(@body_names,$index,1);
  splice(@body_nb_poly,$index,1);
  splice(@colorsRGB,3*$index,3);
}
while(@splice_index) { pop(@splice_index); }

$nb_body = @body_names;

for($polynb=1;$polynb<=(@colorsRGB/3);$polynb++) {
  $trichrom = 3*($polynb-1);
  if($humanoid_definition) {
    if($poly_ref == $body_nb_poly[$poly_index]) { 
      $poly_ref = 0;
      $poly_index++;
    }
    $poly_ref++;
    print MACRO "p3d_set_body_poly_color $body_names[$poly_index].$body_names[$poly_index] $poly_ref "; 
  } elsif($filetype eq 'r') {
    print MACRO "p3d_set_body_poly_color $body_names[$polynb-1].$body_names[$polynb-1] 1 ";
  } else { 
    print MACRO "p3d_set_obst_poly_color $polynb ";
  }    
  print MACRO "Any $colorsRGB[$trichrom] $colorsRGB[$trichrom+1] $colorsRGB[$trichrom+2]\n";
  $compteur++;
}
while(@body_nb_poly) { pop(@body_nb_poly); }
while(@colorsRGB) { pop(@colorsRGB); }
while(@body_hierarchy) { pop(@body_hierarchy); }


if($DoNotGlobalTranslate && $h_anim) {
  rename($last_name.".macrotmp",$last_name.".macro") or die "\nCannot rename file $last_name.macrotmp to $last_name.macro";
  $macro_nb++;
} elsif($empty_macro) {
  close(MACRO);
  $keeplink or unlink($last_name.".macrotmp");
  push(@empty_macro_names,$last_name);
} else {
  &global_translate;
}
while(@body_names) { pop(@body_names); }

print OUTPUT "\np3d_end_desc\n\n";
$max = 100;
print OUTPUT "p3d_set_env_box -$max $max -$max $max -$max $max\n";
$compteur += 2;
if(($filetype eq 'r') || ($h_anim == 0)) {
  print OUTPUT "p3d_sel_desc_name P3D_ROBOT $robot_name\n";
  print OUTPUT "p3d_set_robot_box -$max $max -$max $max -$max $max\n";
  print OUTPUT "p3d_set_robot_pos $robot_global_translation[0] $robot_global_translation[1] $robot_global_translation[2] 0.0\n\n";
  $compteur += 3;
} else {
  print OUTPUT "p3d_set_robot_box -$max $max -$max $max -$max $max\n";
  $compteur++;
}
close(INPUT);
close(OUTPUT);
$keeplink or unlink(<*.*_final>);

## EFFACEMENT DES APPELS A DES MACROS VIDES
if(@empty_macro_names) {
  chdir("..") or die "\nCannot cd ..\n";
  local($output_temp) = $outputfile."tmp";
  rename($outputfile,$output_temp) or die "\nCannot rename file $outputfile to $output_temp\n";
  open(OUTPUT, ">".$outputfile) or die "\nCannot create output file $outputfile\n"; 
  open(TEMP,$output_temp) or die "\nCannot open file $output_temp\n";
  local($copy) = 1;
  while(<TEMP>) {
$AfficheNone or print BUG "#@empty_macro_names#\n";
    $copy = 1;

    if(/p3d_read_macro\s+($name)\.macro\s+($name)/) {
$AfficheNone or print BUG "$name\n";
      EMPTY: for($i=0;$i<=$#empty_macro_names;$i++) {
	  if($1 eq $empty_macro_names[$i]) {
	    splice(@empty_macro_names,$i,1);
	    $copy = 0;
	    last EMPTY;
	  }
	}
    }
   
    if($copy) { print OUTPUT "$_"; }
  }
  close(TEMP);
  $keeplink or unlink($output_temp);
}
close(OUTPUT);

$end_time = time;
$time_spent = $end_time - $beg_time;
$time_spent_sec = $time_spent%60;
$time_spent_min = int($time_spent/60);
print "\n\nCONVERSION $inputfile -> $outputfile completed in $time_spent_min min $time_spent_sec s\n\n";
print "  Number of lines read : $inputnb\n";
print "  Number of lines writen : $compteur\n";
print "  Number of macros created : $macro_nb\n";
unless(($filetype ne 'r') && $h_anim) { 
  print "  Number of bodies in the robot : $nb_body\n";
  print "  Number of joints in the robot : $nb_jnt\n";
}
print "  Number of faces in the scene : $faces\n\n";
if($exception) { print "WARNING: Normal inversions possible\n\t- See $outputfile to localize it -\n"; }

