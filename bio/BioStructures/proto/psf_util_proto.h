/*
 * Copyright (c) 2001-2014 LAAS/CNRS
 * All rights reserved.
 *
 * Redistribution  and  use  in  source  and binary  forms,  with  or  without
 * modification, are permitted provided that the following conditions are met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice and this list of conditions.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice and  this list of  conditions in the  documentation and/or
 *      other materials provided with the distribution.
 *
 * THE SOFTWARE  IS PROVIDED "AS IS"  AND THE AUTHOR  DISCLAIMS ALL WARRANTIES
 * WITH  REGARD   TO  THIS  SOFTWARE  INCLUDING  ALL   IMPLIED  WARRANTIES  OF
 * MERCHANTABILITY AND  FITNESS.  IN NO EVENT  SHALL THE AUTHOR  BE LIABLE FOR
 * ANY  SPECIAL, DIRECT,  INDIRECT, OR  CONSEQUENTIAL DAMAGES  OR  ANY DAMAGES
 * WHATSOEVER  RESULTING FROM  LOSS OF  USE, DATA  OR PROFITS,  WHETHER  IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR  OTHER TORTIOUS ACTION, ARISING OUT OF OR
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.                                  
 *
 * Sim√©on, T., Laumond, J. P., & Lamiraux, F. (2001). 
 * Move3d: A generic platform for path planning. In in 4th Int. Symp.
 * on Assembly and Task Planning.
 */
/*
 *   This file was automatically generated by version 1.7 of cextract.
 *   Manual editing not recommended.

 */
#ifndef __CEXTRACT__

extern void vectSub ( double *a, double *b, double *c );
extern double vectNorm ( double *v );
extern void vectNormalize ( double *src, double *dest );
extern void normalized_vectXprod ( double *a, double *b, double *c );
extern double vectDotProd ( double *a, double *b );
extern int same_sign_vect ( double *v1, double *v2 );
extern void mat4vec3MultPos ( matrix4 a, double *v, vector4 c );
extern void mat4Mult ( matrix4 a, matrix4 b, matrix4 c );
extern void mat4Copy ( matrix4 source, matrix4 dest );
extern void inverse_transf ( matrix4 M, matrix4 inv );
extern void transf_rotz ( double q, matrix4 Trans );
extern void inv_transf_rotz ( double q, matrix4 Trans );
extern double compute_dihedang ( double *nJa, double *tJa, double *pJa );
extern void compute_frame ( double *opos, double *xaxis, double *zaxis, matrix4 Trans );
extern void compute_distance(double *P1, double *P2, double *dist);
extern void compute_dihedang_and_frame ( double *a1pos, double *a2pos, double *a3pos, double *a4pos, double *dihedang, matrix4 Trans );
extern void insert_pointer_in_list ( void *thePt, void ***listPt, int *nelems );
extern void free_pointer_list(void ***listPt, int *size);
/* extern void* remove_last_pointer_from_list(void ***listPt, int* nelems); */
/* extern void* remove_pointer_from_list(void ***listPt, int* nelems, int num); */
/* extern void remove_all_pointers_from_list(void ***listPt, int* nelems); */
extern void insert_integer_in_list(int value, int**listPt, int *nelems);
extern char *psf_givemeword ( char string[], char c, int *index );
extern int get_short_file_name(char* fullFilename, char* shortFileName, int shortMaxSize);
extern file_name_list* init_file_name_list();
extern void free_file_name_list(file_name_list* file_list);

#endif /* __CEXTRACT__ */
