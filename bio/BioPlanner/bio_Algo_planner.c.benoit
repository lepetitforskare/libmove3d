
#include "Collision-pkg.h"
#include "Graphic-pkg.h"
#include "Util-pkg.h"
#include "P3d-pkg.h"
#include "Move3d-pkg.h"
#include "Planner-pkg.h"
#include "Localpath-pkg.h"
#include "Bio-pkg.h"

/*********************************************************************/
int num_subrobot_ligand(void);
/*********************************************************************/
void afficher_lescollisions(void);
/*********************************************************************/
/********* fonctions de bio/enchufe.c ********************************/
/*********************************************************************/
int bio_molecule_col(int nrobot);
int bio_molecule_autocol(int i);
void bio_set_col_mode(int mode);
void biocol_report(int *col_number, p3d_poly ***list1, p3d_poly ***list2);
/*********************************************************************/
double dist_sphere(p3d_poly *p1, p3d_poly *p2);
/*********************************************************************/
void afficher_les_plus_proches_col(int num);
void afficher_les_non_autocol(void);
void select_plus_proches_paires(p3d_poly **p1, p3d_poly **p2, int nb_col,
				p3d_poly ***p1_trunc, p3d_poly ***p2_trunc, int *num);
void col_tot_moins_autocol(p3d_poly **p1_tot, p3d_poly **p2_tot, int nb_col_tot,
			   p3d_poly **p1_auto, p3d_poly **p2_auto, int nb_col_auto,
			   p3d_poly ***p1_res, p3d_poly ***p2_res, int *num);
void vecteur_for_retract_lig(p3d_poly **p1, p3d_poly **p2, int nb_col,
			     p3d_vector3 *vect_res );
static int id_poly_lig(void);
static double norme(p3d_vector3 p);
/*********************************************************************/


void plus_proche_ligand(void)
{
  int num_lig = num_subrobot_ligand();

  if(num_lig > 0)
    {
      puts("on teste les plus proche du ligand");
      puts("bioCC passe en mode SURFACE_DISTANCE_BIOCOL_MODE ");
      bio_set_col_mode(SURFACE_DISTANCE_BIOCOL_MODE);
      
      if(G3D_ACTIVE_CC)
	{ 
	  p3d_col_test_all();
	  bio_molecule_autocol( num_lig ); // test les autocol du ligand
	  afficher_lescollisions();
	  bio_molecule_col( num_lig );     // test les col du lig avec ts les subrobots
	  afficher_lescollisions();
	  puts("PLUS PROCHES COLLISIONS");
	  afficher_les_plus_proches_col(3);
	  puts("LES NON AUTOCOL !!!");
	  afficher_les_non_autocol();
	  
	}
      else puts("ERROR : pas de CC actif");
      puts("bioCC passe en mode NORMAL_BIOCOL_MODE ");
      bio_set_col_mode(NORMAL_BIOCOL_MODE);
    }
  else puts("desole pas de ligand !!");
}


// parametres :
// p1 et p2             : la liste des paires en collision ou a une distance inferieure a une valeur donnee
// nb_col               : nombre d'element dans p1 et p2
// p1_trunc et p2_trunc : on place dedans la liste des num plus proches paires
// num                  : nombre de paires a selectionner 
//                        (en sortie on a le nombre effectivement le nb d'el selectionnes )  

void select_plus_proches_paires(p3d_poly **p1, p3d_poly **p2, int nb_col,
				p3d_poly ***p1_trunc, p3d_poly ***p2_trunc, int *num) 
{
  int i,j,k;
  int place = 0;
  /*  int fini = 0; */
  double dist_cour = 0.0;
  p3d_poly **p1_tr = MY_ALLOC(p3d_poly *, *num);
  p3d_poly **p2_tr = MY_ALLOC(p3d_poly *, *num); 
  int poly_lig = id_poly_lig();
  
  for(i=0;i<nb_col;i++)
    {
      dist_cour = dist_sphere(p1[i], p2[i]);
      j=0;
      place = 0;
      while((j<*num)&&(!place))
	{
	  /* 	  for(j=0;j<*num;j++) */
	  /* 	    { */
/* 	  if((!p1_tr[j])||(!p2_tr[j]))  */
	  if((j>=i)&&(j<*num))
	    {
	      if(p1[i]->id >= poly_lig ) // ici p1[i] appartient au lig -> en premiere pos
		{
		  p1_tr[j] = p1[i];
		  p2_tr[j] = p2[i];	
		}
	      else                       // ici p1[i] n'appartient pas au lig -> en deuxieme pos
		{                        // si on a enleve les autocol : on est sur que le poly du lig est en 1ere pos
		  p1_tr[j] = p2[i];
		  p2_tr[j] = p1[i];		  
		}
	      place = 1;
	    }
	  else
	    {
	      if(dist_cour<dist_sphere(p1_tr[j],p2_tr[j]) ) // on deplace tt les autres et on place celui-ci
		{
		  /* 		  fini = 0; */
		  /* 		  for(k=(j+1);(k<*num)&&(!fini);k++) */
		  /* 		    { */
		  /* 		      p1_tr[k] = p1_tr[k-1]; */
		  /* 		      p2_tr[k] = p2_tr[k-1]; */
		  /* 		      if(k+1<*num) if(!p1_tr[k+1]) fini = 1; */
		  /* 		    } */
		  /* 		  fini = 0; */
		  for(k=(*num-1);k>j;k--)
		    {
		      p1_tr[k] = p1_tr[k-1];
		      p2_tr[k] = p2_tr[k-1];
		      /* 	      if(k+1<*num) if(!p1_tr[k+1]) fini = 1; */
		    }
		  if(p1[i]->id >= poly_lig ) // ici p1[i] appartient au lig -> en premiere pos
		    {
		      p1_tr[j] = p1[i];
		      p2_tr[j] = p2[i];	
		    }
		  else                       // ici p1[i] n'appartient pas au lig -> en deuxieme pos
		    {                        // si on a enleve les autocol : on est sur que le poly du lig est en 1ere pos
		      p1_tr[j] = p2[i];
		      p2_tr[j] = p1[i];		  
		    }
		  place = 1;
		}
	    } //fin else
	  j++;
	  /* 	    }  fin for j  */
	} // fin while
    } // fin for i
  *p1_trunc = p1_tr;
  *p2_trunc = p2_tr;
  if(nb_col < *num) *num = nb_col; // si on a moins de paires que de paires souhaitees : num <- nb_col
}


void afficher_les_plus_proches_col(int num)
{
  int i = 0;
  int col_number;
  p3d_poly **p1,**p2;
  p3d_poly **p1_tr, **p2_tr;

  biocol_report(&col_number, &p1, &p2);
  select_plus_proches_paires(p1, p2, col_number, &p1_tr, &p2_tr, &num); 

  printf("nb de paires selectionnees : %d \n",num);

  for(i=0;i<num;i++)
    {
      if(p1_tr[i]&&p2_tr[i])
	printf("jnts en col : %s   %s a la dist  %f \n",p1_tr[i]->poly->name,
	       p2_tr[i]->poly->name,dist_sphere(p1_tr[i],p2_tr[i]));
      else puts("WARNING : nombres de paires en collision inf au nb demande : augmenter le rayon du CC");
    }

}

void afficher_les_non_autocol(void)
{
  int i;
  int num_lig = num_subrobot_ligand();
  int nb_col_tot, nb_col_auto, nb_col_res;
  p3d_poly **p1_tot,**p2_tot;
  p3d_poly **p1_auto,**p2_auto;
  p3d_poly **p1_res,**p2_res;  
  p3d_vector3 vect_res;

  p3d_col_test_all();
  bio_molecule_autocol( num_lig ); // test les autocol du ligand
  biocol_report(&nb_col_auto, &p1_auto, &p2_auto);
  bio_molecule_col( num_lig );     // test les col du lig avec ts les subrobots
  biocol_report(&nb_col_tot, &p1_tot, &p2_tot);

  col_tot_moins_autocol(p1_tot, p2_tot, nb_col_tot,
			p1_auto, p2_auto, nb_col_auto,
			&p1_res, &p2_res, &nb_col_res);
  for(i=0;i<nb_col_res;i++)
    {
      printf("jnts en col : %s   %s a la dist  %f \n",p1_res[i]->poly->name,
	     p2_res[i]->poly->name,dist_sphere(p1_res[i],p2_res[i]));
    }
  
  puts("AFFICHAGE DU VECTEUR RESULTANT : ");
  vecteur_for_retract_lig(p1_res, p2_res, nb_col_res, &vect_res);
  for(i=0;i<3;i++) printf("coord : %f \n",vect_res[i]);
}


void col_tot_moins_autocol(p3d_poly **p1_tot, p3d_poly **p2_tot, int nb_col_tot,
			   p3d_poly **p1_auto, p3d_poly **p2_auto, int nb_col_auto,
			   p3d_poly ***p1_res, p3d_poly ***p2_res, int *num)
{
  int id1 = 0;
  int id2 = 0;
  int i,j;
  int paire_autocol = 0;
  p3d_poly **p1_tr = MY_ALLOC(p3d_poly *, nb_col_tot - nb_col_auto);
  p3d_poly **p2_tr = MY_ALLOC(p3d_poly *, nb_col_tot - nb_col_auto); 

  *num = 0;

  for(i=0;i<nb_col_tot;i++)
    {
      id1 = p1_tot[i]->id;
      id2 = p2_tot[i]->id;      
      for(j=0;(j<nb_col_auto)&&(!paire_autocol);j++)
	{
	  paire_autocol = ( ((id1 == p1_auto[j]->id) && (id2 == p2_auto[j]->id))
			    || ((id1 == p2_auto[j]->id) && (id2 == p1_auto[j]->id)) ); 
	}
      if(!paire_autocol) 
	{
	  (*num)++;
	  p1_tr[(*num)-1] = p1_tot[i];
	  p2_tr[(*num)-1] = p2_tot[i];
	}
      else paire_autocol = 0;
    }
  
  *p1_res = p1_tr;
  *p2_res = p2_tr;
}


static int id_poly_lig(void)
{
  int id = 0;
  int num_jnt_lig = num_subrobot_ligand();  
  p3d_rob *robotPt = (p3d_rob*)p3d_get_desc_curid(P3D_ROBOT);
  p3d_jnt *jntPt = robotPt->joints[num_jnt_lig];

  id = jntPt->o->pol[0]->id; // recupere l'id du premier poly du premier jnt du ligand

  return id;
}


void vecteur_for_retract_lig(p3d_poly **p1, p3d_poly **p2, int nb_col,
			     p3d_vector3 *vect_res )
{
  int i,j;
  p3d_vector3 vect_cour;
  double norm_cour = 0;
  
  for(j=0;j<3;j++) *vect_res[j] = 0.0; 
  
  for(i=0;i<nb_col;i++)
    {
      // on recuere le vecteur force qui s'applique sur le ligand
      for(j=0;j<3;j++) vect_cour[j] = p1[i]->pos[j] - p2[i]->pos[j];
      // onle normalise
      // *********************************************************
      // ATTENTION : HEURISTIQUE : A MODIFIER CERTAINEMENT
      // on somme les vecteurs divise par leur norme au carre 
      // dc les + proche atomes auront plus d'influence 
      // *********************************************************
      norm_cour = norme(vect_cour);
      for(j=0;j<3;j++) vect_cour[j] = vect_cour[j]/(norm_cour*norm_cour);
      // on l'ajoute au vecteur total
      for(j=0;j<3;j++) *vect_res[j] = *vect_res[j] + vect_cour[j];       
    }
}

static double norme(p3d_vector3 p)
{
  return sqrt(p[1]*p[1]+p[2]*p[2]+p[3]*p[3]);
}
