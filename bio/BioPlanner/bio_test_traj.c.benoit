#include "Collision-pkg.h"
#include "Graphic-pkg.h"
#include "Util-pkg.h"
#include "P3d-pkg.h"
#include "Move3d-pkg.h"
#include "Planner-pkg.h"
#include "Localpath-pkg.h"
#include "Bio-pkg.h"

#define SQR_DIST ((f= *(v1) - *(v2)) * f) + ((f= *(++v1) - *(++v2)) * f) + ((f= *(++v1) - *(++v2)) * f)

/*********************************************************************************/
void bio_set_col_mode(int mode);
/* void min_dist_report(int *min_dist, p3d_poly **poly1, p3d_poly **poly2); */
void min_dist_report(p3d_poly **poly1, p3d_poly **poly2);
/*********************************************************************************/
void afficher_lescollisions(void);
double get_VdW_pourcent(void);
/*********************************************************************************/
static double dist_poly(p3d_poly *p1, p3d_poly *p2);
double dist_sphere(p3d_poly *p1, p3d_poly *p2);
static double rayon_VDW(p3d_poly *p3d_poly);
static double dist_VdW(p3d_poly *p1, p3d_poly *p2);
/*********************************************************************************/

void bio_test_traj()
{
  int ncol = 0;
  double length_totale = 0.0;
  configPt q = NULL; 
  p3d_rob *robotPt = NULL;
  p3d_traj *trajPt = NULL;
  p3d_localpath *localpathPt = NULL;

  p3d_poly *p1,*p2;
  //  int distance_min;

  trajPt = p3d_get_desc_curid(P3D_TRAJ);
  robotPt = trajPt->rob;
  localpathPt = trajPt->courbePt;

  puts("Debut de l'estimation de la trajectoire : ");
  
  puts("bioCC passe en mode MINIMUM_DISTANCE_BIOCOL_MODE ");
  bio_set_col_mode(MINIMUM_DISTANCE_BIOCOL_MODE);

  /* Pour la premiere configuration */
  q = localpathPt->config_at_distance(robotPt, localpathPt, 0);
  p3d_set_robot_config(robotPt, q);
  p3d_update_robot_pos();
  /********** manque un truc ******************/
  if(G3D_ACTIVE_CC) ncol = p3d_col_test_all();
  printf("A la distance : %f  ",length_totale);
  min_dist_report(&p1, &p2);
  printf("joints en collision : %s   %s a la distance : %f \n", p1->poly->name, p2->poly->name, dist_poly(p1,p2) );
  printf("sphere a distance : %f \n",dist_sphere(p1,p2));
  printf("Maximum du pourcent de VdW : %f \n",dist_VdW(p1,p2) );
  /*   afficher_lescollisions(); */
  /********** manque un truc ******************/  

  while (localpathPt != NULL){
    
    length_totale = length_totale + localpathPt->length_lp;
    q = localpathPt->config_at_distance(robotPt, localpathPt, localpathPt->length_lp);
    p3d_set_robot_config(robotPt, q);
    p3d_update_robot_pos();
    /********** manque un truc ******************/
    if(G3D_ACTIVE_CC) ncol = p3d_col_test_all();
    printf("A la distance : %f  ",length_totale);
    min_dist_report(&p1, &p2);
    printf("joints en collision : %s   %s a la distance : %f \n", p1->poly->name, p2->poly->name, dist_poly(p1,p2) );
    printf("sphere a distance : %f \n",dist_sphere(p1,p2));
    printf("Maximum du pourcent de VdW : %f \n",dist_VdW(p1,p2) );
/*     afficher_lescollisions(); */
    /********** manque un truc ******************/

    localpathPt = localpathPt->next_lp;
  }
  puts("Fin de l'estimation de la trajectoire");
  
  /* desallocate vectors p and p_deg */
  p3d_destroy_config(robotPt, q);     
  /* On suppose que le mode initial du bioCC est le mode normal ... */
  puts("bioCC passe en mode NORMAL_BIOCOL_MODE ");
  bio_set_col_mode(NORMAL_BIOCOL_MODE);
}

static double dist_poly(p3d_poly *p1, p3d_poly *p2)
{
  register double *v1= p1->pos;
  register double *v2= p2->pos;
  register double f;

  return sqrt(SQR_DIST);
}

double dist_sphere(p3d_poly *p1, p3d_poly *p2)
{
  double d =  dist_poly(p1,p2);
  double R1 = rayon_VDW(p1);
  double R2 = rayon_VDW(p2);
  double dist_cherchee = 0.0;
  double VdW_pourcent = get_VdW_pourcent();

  dist_cherchee = d - VdW_pourcent*(R1+R2);

  return dist_cherchee;
}

static double dist_VdW(p3d_poly *p1, p3d_poly *p2)
{
  double pourcent_max = 0;
  double R1 = rayon_VDW(p1);
  double R2 = rayon_VDW(p2);

  pourcent_max = dist_poly(p1,p2)/(R1+R2);

  return pourcent_max;
}

static double rayon_VDW(p3d_poly *p3d_poly)
{
  int lookat=2;
  double rayon_atom = 0.0;
  char c= p3d_poly->poly->name[lookat];

  switch(c){
  case 'N': 
    rayon_atom = 1.55;
    break;
  case 'C':
    if (p3d_poly->poly->name[lookat + 1] != 'l') rayon_atom = 1.7;
    else rayon_atom = 1.75;
    break;
  case 'H': 
    rayon_atom = 1.2;
    break;
  case 'S': 
    rayon_atom = 1.8;
    break;
  case 'O': 
    rayon_atom = 1.52;
    break;
  case 'B': 
    rayon_atom = 1.85;
    break;
  case 'I': 
    rayon_atom = 1.98;
    break;
  case 'F': 
    rayon_atom = 1.47;
    break;
  case 'P': 
    rayon_atom = 1.80;
    break;
  default:
    if ((c >= '1') && (c <= '9')) rayon_atom = 1.2;
    else printf("Unknown type of atom in rayon_VdW\n");
  }
  return rayon_atom;
}
